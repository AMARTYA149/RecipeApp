{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/amartya_aishwarya/Desktop/nextjs-angular/RecipeApp/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RouterExplorer = void 0;\n\nconst constants_1 = require(\"@nestjs/common/constants\");\n\nconst version_type_enum_1 = require(\"@nestjs/common/enums/version-type.enum\");\n\nconst exceptions_1 = require(\"@nestjs/common/exceptions\");\n\nconst version_options_interface_1 = require(\"@nestjs/common/interfaces/version-options.interface\");\n\nconst logger_service_1 = require(\"@nestjs/common/services/logger.service\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst pathToRegexp = require(\"path-to-regexp\");\n\nconst unknown_request_mapping_exception_1 = require(\"../errors/exceptions/unknown-request-mapping.exception\");\n\nconst guards_consumer_1 = require(\"../guards/guards-consumer\");\n\nconst guards_context_creator_1 = require(\"../guards/guards-context-creator\");\n\nconst context_id_factory_1 = require(\"../helpers/context-id-factory\");\n\nconst execution_context_host_1 = require(\"../helpers/execution-context-host\");\n\nconst messages_1 = require(\"../helpers/messages\");\n\nconst router_method_factory_1 = require(\"../helpers/router-method-factory\");\n\nconst constants_2 = require(\"../injector/constants\");\n\nconst interceptors_consumer_1 = require(\"../interceptors/interceptors-consumer\");\n\nconst interceptors_context_creator_1 = require(\"../interceptors/interceptors-context-creator\");\n\nconst pipes_consumer_1 = require(\"../pipes/pipes-consumer\");\n\nconst pipes_context_creator_1 = require(\"../pipes/pipes-context-creator\");\n\nconst request_constants_1 = require(\"./request/request-constants\");\n\nconst route_params_factory_1 = require(\"./route-params-factory\");\n\nconst router_execution_context_1 = require(\"./router-execution-context\");\n\nclass RouterExplorer {\n  constructor(metadataScanner, container, injector, routerProxy, exceptionsFilter, config, routePathFactory) {\n    this.metadataScanner = metadataScanner;\n    this.container = container;\n    this.injector = injector;\n    this.routerProxy = routerProxy;\n    this.exceptionsFilter = exceptionsFilter;\n    this.config = config;\n    this.routePathFactory = routePathFactory;\n    this.routerMethodFactory = new router_method_factory_1.RouterMethodFactory();\n    this.logger = new logger_service_1.Logger(RouterExplorer.name, {\n      timestamp: true\n    });\n    this.exceptionFiltersCache = new WeakMap();\n    const routeParamsFactory = new route_params_factory_1.RouteParamsFactory();\n    const pipesContextCreator = new pipes_context_creator_1.PipesContextCreator(container, config);\n    const pipesConsumer = new pipes_consumer_1.PipesConsumer();\n    const guardsContextCreator = new guards_context_creator_1.GuardsContextCreator(container, config);\n    const guardsConsumer = new guards_consumer_1.GuardsConsumer();\n    const interceptorsContextCreator = new interceptors_context_creator_1.InterceptorsContextCreator(container, config);\n    const interceptorsConsumer = new interceptors_consumer_1.InterceptorsConsumer();\n    this.executionContextCreator = new router_execution_context_1.RouterExecutionContext(routeParamsFactory, pipesContextCreator, pipesConsumer, guardsContextCreator, guardsConsumer, interceptorsContextCreator, interceptorsConsumer, container.getHttpAdapterRef());\n  }\n\n  explore(instanceWrapper, moduleKey, applicationRef, host, routePathMetadata) {\n    const {\n      instance\n    } = instanceWrapper;\n    const routerPaths = this.scanForPaths(instance);\n    this.applyPathsToRouterProxy(applicationRef, routerPaths, instanceWrapper, moduleKey, routePathMetadata, host);\n  }\n\n  extractRouterPath(metatype) {\n    const path = Reflect.getMetadata(constants_1.PATH_METADATA, metatype);\n\n    if ((0, shared_utils_1.isUndefined)(path)) {\n      throw new unknown_request_mapping_exception_1.UnknownRequestMappingException();\n    }\n\n    if (Array.isArray(path)) {\n      return path.map(p => (0, shared_utils_1.addLeadingSlash)(p));\n    }\n\n    return [(0, shared_utils_1.addLeadingSlash)(path)];\n  }\n\n  scanForPaths(instance, prototype) {\n    const instancePrototype = (0, shared_utils_1.isUndefined)(prototype) ? Object.getPrototypeOf(instance) : prototype;\n    return this.metadataScanner.scanFromPrototype(instance, instancePrototype, method => this.exploreMethodMetadata(instance, instancePrototype, method));\n  }\n\n  exploreMethodMetadata(instance, prototype, methodName) {\n    const instanceCallback = instance[methodName];\n    const prototypeCallback = prototype[methodName];\n    const routePath = Reflect.getMetadata(constants_1.PATH_METADATA, prototypeCallback);\n\n    if ((0, shared_utils_1.isUndefined)(routePath)) {\n      return null;\n    }\n\n    const requestMethod = Reflect.getMetadata(constants_1.METHOD_METADATA, prototypeCallback);\n    const version = Reflect.getMetadata(constants_1.VERSION_METADATA, prototypeCallback);\n    const path = (0, shared_utils_1.isString)(routePath) ? [(0, shared_utils_1.addLeadingSlash)(routePath)] : routePath.map(p => (0, shared_utils_1.addLeadingSlash)(p));\n    return {\n      path,\n      requestMethod,\n      targetCallback: instanceCallback,\n      methodName,\n      version\n    };\n  }\n\n  applyPathsToRouterProxy(router, routeDefinitions, instanceWrapper, moduleKey, routePathMetadata, host) {\n    (routeDefinitions || []).forEach(routeDefinition => {\n      const {\n        version: methodVersion\n      } = routeDefinition;\n      routePathMetadata.methodVersion = methodVersion;\n      this.applyCallbackToRouter(router, routeDefinition, instanceWrapper, moduleKey, routePathMetadata, host);\n    });\n  }\n\n  applyCallbackToRouter(router, routeDefinition, instanceWrapper, moduleKey, routePathMetadata, host) {\n    const {\n      path: paths,\n      requestMethod,\n      targetCallback,\n      methodName\n    } = routeDefinition;\n    const {\n      instance\n    } = instanceWrapper;\n    const routerMethodRef = this.routerMethodFactory.get(router, requestMethod).bind(router);\n    const isRequestScoped = !instanceWrapper.isDependencyTreeStatic();\n    const proxy = isRequestScoped ? this.createRequestScopedHandler(instanceWrapper, requestMethod, this.container.getModuleByKey(moduleKey), moduleKey, methodName) : this.createCallbackProxy(instance, targetCallback, methodName, moduleKey, requestMethod);\n    const isVersioned = (routePathMetadata.methodVersion || routePathMetadata.controllerVersion) && routePathMetadata.versioningOptions;\n    let routeHandler = this.applyHostFilter(host, proxy);\n    paths.forEach(path => {\n      if (isVersioned && routePathMetadata.versioningOptions.type !== version_type_enum_1.VersioningType.URI) {\n        // All versioning (except for URI Versioning) is done via the \"Version Filter\"\n        routeHandler = this.applyVersionFilter(router, routePathMetadata, routeHandler);\n      }\n\n      routePathMetadata.methodPath = path;\n      const pathsToRegister = this.routePathFactory.create(routePathMetadata, requestMethod);\n      pathsToRegister.forEach(path => routerMethodRef(path, routeHandler));\n      const pathsToLog = this.routePathFactory.create(Object.assign(Object.assign({}, routePathMetadata), {\n        versioningOptions: undefined\n      }), requestMethod);\n      pathsToLog.forEach(path => {\n        if (isVersioned) {\n          const version = this.routePathFactory.getVersion(routePathMetadata);\n          this.logger.log((0, messages_1.VERSIONED_ROUTE_MAPPED_MESSAGE)(path, requestMethod, version));\n        } else {\n          this.logger.log((0, messages_1.ROUTE_MAPPED_MESSAGE)(path, requestMethod));\n        }\n      });\n    });\n  }\n\n  applyHostFilter(host, handler) {\n    if (!host) {\n      return handler;\n    }\n\n    const httpAdapterRef = this.container.getHttpAdapterRef();\n    const hosts = Array.isArray(host) ? host : [host];\n    const hostRegExps = hosts.map(host => {\n      const keys = [];\n      const regexp = pathToRegexp(host, keys);\n      return {\n        regexp,\n        keys\n      };\n    });\n    const unsupportedFilteringErrorMessage = Array.isArray(host) ? `HTTP adapter does not support filtering on hosts: [\"${host.join('\", \"')}\"]` : `HTTP adapter does not support filtering on host: \"${host}\"`;\n    return (req, res, next) => {\n      req.hosts = {};\n      const hostname = httpAdapterRef.getRequestHostname(req) || '';\n\n      for (const exp of hostRegExps) {\n        const match = hostname.match(exp.regexp);\n\n        if (match) {\n          exp.keys.forEach((key, i) => req.hosts[key.name] = match[i + 1]);\n          return handler(req, res, next);\n        }\n      }\n\n      if (!next) {\n        throw new exceptions_1.InternalServerErrorException(unsupportedFilteringErrorMessage);\n      }\n\n      return next();\n    };\n  }\n\n  applyVersionFilter(router, routePathMetadata, handler) {\n    const {\n      versioningOptions\n    } = routePathMetadata;\n    const version = this.routePathFactory.getVersion(routePathMetadata);\n\n    if (router === null || router === void 0 ? void 0 : router.applyVersionFilter) {\n      return router.applyVersionFilter(handler, version, versioningOptions);\n    }\n    /**\n     * TODO(v9): This was left for backward-compatibility and can be removed.\n     */\n\n\n    return (req, res, next) => {\n      var _a, _b, _c, _d;\n\n      if (version === version_options_interface_1.VERSION_NEUTRAL) {\n        return handler(req, res, next);\n      } // URL Versioning is done via the path, so the filter continues forward\n\n\n      if (versioningOptions.type === version_type_enum_1.VersioningType.URI) {\n        return handler(req, res, next);\n      } // Custom Extractor Versioning Handler\n\n\n      if (versioningOptions.type === version_type_enum_1.VersioningType.CUSTOM) {\n        const extractedVersion = versioningOptions.extractor(req);\n\n        if (Array.isArray(version)) {\n          if (Array.isArray(extractedVersion) && version.filter(extractedVersion.includes).length) {\n            return handler(req, res, next);\n          } else if ((0, shared_utils_1.isString)(extractedVersion) && version.includes(extractedVersion)) {\n            return handler(req, res, next);\n          }\n        } else {\n          if (Array.isArray(extractedVersion) && extractedVersion.includes(version)) {\n            return handler(req, res, next);\n          } else if ((0, shared_utils_1.isString)(extractedVersion) && version === extractedVersion) {\n            return handler(req, res, next);\n          }\n        }\n      } // Media Type (Accept Header) Versioning Handler\n\n\n      if (versioningOptions.type === version_type_enum_1.VersioningType.MEDIA_TYPE) {\n        const MEDIA_TYPE_HEADER = 'Accept';\n        const acceptHeaderValue = ((_a = req.headers) === null || _a === void 0 ? void 0 : _a[MEDIA_TYPE_HEADER]) || ((_b = req.headers) === null || _b === void 0 ? void 0 : _b[MEDIA_TYPE_HEADER.toLowerCase()]);\n        const acceptHeaderVersionParameter = acceptHeaderValue ? acceptHeaderValue.split(';')[1] : undefined; // No version was supplied\n\n        if ((0, shared_utils_1.isUndefined)(acceptHeaderVersionParameter)) {\n          if (Array.isArray(version)) {\n            if (version.includes(version_options_interface_1.VERSION_NEUTRAL)) {\n              return handler(req, res, next);\n            }\n          }\n        } else {\n          const headerVersion = acceptHeaderVersionParameter.split(versioningOptions.key)[1];\n\n          if (Array.isArray(version)) {\n            if (version.includes(headerVersion)) {\n              return handler(req, res, next);\n            }\n          } else if ((0, shared_utils_1.isString)(version)) {\n            if (version === headerVersion) {\n              return handler(req, res, next);\n            }\n          }\n        }\n      } // Header Versioning Handler\n      else if (versioningOptions.type === version_type_enum_1.VersioningType.HEADER) {\n        const customHeaderVersionParameter = ((_c = req.headers) === null || _c === void 0 ? void 0 : _c[versioningOptions.header]) || ((_d = req.headers) === null || _d === void 0 ? void 0 : _d[versioningOptions.header.toLowerCase()]); // No version was supplied\n\n        if ((0, shared_utils_1.isUndefined)(customHeaderVersionParameter)) {\n          if (Array.isArray(version)) {\n            if (version.includes(version_options_interface_1.VERSION_NEUTRAL)) {\n              return handler(req, res, next);\n            }\n          }\n        } else {\n          if (Array.isArray(version)) {\n            if (version.includes(customHeaderVersionParameter)) {\n              return handler(req, res, next);\n            }\n          } else if ((0, shared_utils_1.isString)(version)) {\n            if (version === customHeaderVersionParameter) {\n              return handler(req, res, next);\n            }\n          }\n        }\n      }\n\n      if (!next) {\n        throw new exceptions_1.InternalServerErrorException('HTTP adapter does not support filtering on version');\n      }\n\n      return next();\n    };\n  }\n\n  createCallbackProxy(instance, callback, methodName, moduleRef, requestMethod, contextId = constants_2.STATIC_CONTEXT, inquirerId) {\n    const executionContext = this.executionContextCreator.create(instance, callback, methodName, moduleRef, requestMethod, contextId, inquirerId);\n    const exceptionFilter = this.exceptionsFilter.create(instance, callback, moduleRef, contextId, inquirerId);\n    return this.routerProxy.createProxy(executionContext, exceptionFilter);\n  }\n\n  createRequestScopedHandler(instanceWrapper, requestMethod, moduleRef, moduleKey, methodName) {\n    var _this = this;\n\n    const {\n      instance\n    } = instanceWrapper;\n    const collection = moduleRef.controllers;\n    return /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (req, res, next) {\n        try {\n          const contextId = _this.getContextId(req);\n\n          const contextInstance = yield _this.injector.loadPerContext(instance, moduleRef, collection, contextId);\n          yield _this.createCallbackProxy(contextInstance, contextInstance[methodName], methodName, moduleKey, requestMethod, contextId, instanceWrapper.id)(req, res, next);\n        } catch (err) {\n          let exceptionFilter = _this.exceptionFiltersCache.get(instance[methodName]);\n\n          if (!exceptionFilter) {\n            exceptionFilter = _this.exceptionsFilter.create(instance, instance[methodName], moduleKey);\n\n            _this.exceptionFiltersCache.set(instance[methodName], exceptionFilter);\n          }\n\n          const host = new execution_context_host_1.ExecutionContextHost([req, res, next]);\n          exceptionFilter.next(err, host);\n        }\n      });\n\n      return function (_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n\n  getContextId(request) {\n    const contextId = context_id_factory_1.ContextIdFactory.getByRequest(request);\n\n    if (!request[request_constants_1.REQUEST_CONTEXT_ID]) {\n      Object.defineProperty(request, request_constants_1.REQUEST_CONTEXT_ID, {\n        value: contextId,\n        enumerable: false,\n        writable: false,\n        configurable: false\n      });\n      this.container.registerRequestProvider(request, contextId);\n    }\n\n    return contextId;\n  }\n\n}\n\nexports.RouterExplorer = RouterExplorer;","map":null,"metadata":{},"sourceType":"script"}