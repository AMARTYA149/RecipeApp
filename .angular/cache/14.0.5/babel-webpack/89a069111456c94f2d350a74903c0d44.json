{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/amartya_aishwarya/Desktop/nextjs-angular/RecipeApp/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Module = void 0;\n\nconst random_string_generator_util_1 = require(\"@nestjs/common/utils/random-string-generator.util\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst iterare_1 = require(\"iterare\");\n\nconst application_config_1 = require(\"../application-config\");\n\nconst invalid_class_exception_1 = require(\"../errors/exceptions/invalid-class.exception\");\n\nconst runtime_exception_1 = require(\"../errors/exceptions/runtime.exception\");\n\nconst unknown_export_exception_1 = require(\"../errors/exceptions/unknown-export.exception\");\n\nconst context_id_factory_1 = require(\"../helpers/context-id-factory\");\n\nconst get_class_scope_1 = require(\"../helpers/get-class-scope\");\n\nconst constants_1 = require(\"./constants\");\n\nconst instance_wrapper_1 = require(\"./instance-wrapper\");\n\nconst module_ref_1 = require(\"./module-ref\");\n\nclass Module {\n  constructor(_metatype, container) {\n    this._metatype = _metatype;\n    this.container = container;\n    this._imports = new Set();\n    this._providers = new Map();\n    this._injectables = new Map();\n    this._middlewares = new Map();\n    this._controllers = new Map();\n    this._exports = new Set();\n    this._distance = 0;\n    this.addCoreProviders();\n    this._id = (0, random_string_generator_util_1.randomStringGenerator)();\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get token() {\n    return this._token;\n  }\n\n  set token(token) {\n    this._token = token;\n  }\n\n  get providers() {\n    return this._providers;\n  }\n\n  get middlewares() {\n    return this._middlewares;\n  }\n\n  get imports() {\n    return this._imports;\n  }\n  /**\n   * Left for backward-compatibility reasons\n   */\n\n\n  get relatedModules() {\n    return this._imports;\n  }\n  /**\n   * Left for backward-compatibility reasons\n   */\n\n\n  get components() {\n    return this._providers;\n  }\n  /**\n   * Left for backward-compatibility reasons\n   */\n\n\n  get routes() {\n    return this._controllers;\n  }\n\n  get injectables() {\n    return this._injectables;\n  }\n\n  get controllers() {\n    return this._controllers;\n  }\n\n  get exports() {\n    return this._exports;\n  }\n\n  get instance() {\n    if (!this._providers.has(this._metatype)) {\n      throw new runtime_exception_1.RuntimeException();\n    }\n\n    const module = this._providers.get(this._metatype);\n\n    return module.instance;\n  }\n\n  get metatype() {\n    return this._metatype;\n  }\n\n  get distance() {\n    return this._distance;\n  }\n\n  set distance(value) {\n    this._distance = value;\n  }\n\n  addCoreProviders() {\n    this.addModuleAsProvider();\n    this.addModuleRef();\n    this.addApplicationConfig();\n  }\n\n  addModuleRef() {\n    const moduleRef = this.createModuleReferenceType();\n\n    this._providers.set(module_ref_1.ModuleRef, new instance_wrapper_1.InstanceWrapper({\n      token: module_ref_1.ModuleRef,\n      name: module_ref_1.ModuleRef.name,\n      metatype: module_ref_1.ModuleRef,\n      isResolved: true,\n      instance: new moduleRef(),\n      host: this\n    }));\n  }\n\n  addModuleAsProvider() {\n    this._providers.set(this._metatype, new instance_wrapper_1.InstanceWrapper({\n      token: this._metatype,\n      name: this._metatype.name,\n      metatype: this._metatype,\n      isResolved: false,\n      instance: null,\n      host: this\n    }));\n  }\n\n  addApplicationConfig() {\n    this._providers.set(application_config_1.ApplicationConfig, new instance_wrapper_1.InstanceWrapper({\n      token: application_config_1.ApplicationConfig,\n      name: application_config_1.ApplicationConfig.name,\n      isResolved: true,\n      instance: this.container.applicationConfig,\n      host: this\n    }));\n  }\n\n  addInjectable(injectable, host) {\n    if (this.isCustomProvider(injectable)) {\n      return this.addCustomProvider(injectable, this._injectables);\n    }\n\n    let instanceWrapper = this.injectables.get(injectable);\n\n    if (!instanceWrapper) {\n      instanceWrapper = new instance_wrapper_1.InstanceWrapper({\n        token: injectable,\n        name: injectable.name,\n        metatype: injectable,\n        instance: null,\n        isResolved: false,\n        scope: (0, get_class_scope_1.getClassScope)(injectable),\n        host: this\n      });\n\n      this._injectables.set(injectable, instanceWrapper);\n    }\n\n    if (host) {\n      const hostWrapper = this._controllers.get(host) || this._providers.get(host);\n\n      hostWrapper && hostWrapper.addEnhancerMetadata(instanceWrapper);\n    }\n  }\n\n  addProvider(provider) {\n    if (this.isCustomProvider(provider)) {\n      return this.addCustomProvider(provider, this._providers);\n    }\n\n    this._providers.set(provider, new instance_wrapper_1.InstanceWrapper({\n      token: provider,\n      name: provider.name,\n      metatype: provider,\n      instance: null,\n      isResolved: false,\n      scope: (0, get_class_scope_1.getClassScope)(provider),\n      host: this\n    }));\n\n    return provider;\n  }\n\n  isCustomProvider(provider) {\n    return !(0, shared_utils_1.isNil)(provider.provide);\n  }\n\n  addCustomProvider(provider, collection) {\n    if (this.isCustomClass(provider)) {\n      this.addCustomClass(provider, collection);\n    } else if (this.isCustomValue(provider)) {\n      this.addCustomValue(provider, collection);\n    } else if (this.isCustomFactory(provider)) {\n      this.addCustomFactory(provider, collection);\n    } else if (this.isCustomUseExisting(provider)) {\n      this.addCustomUseExisting(provider, collection);\n    }\n\n    return provider.provide;\n  }\n\n  isCustomClass(provider) {\n    return !(0, shared_utils_1.isUndefined)(provider.useClass);\n  }\n\n  isCustomValue(provider) {\n    return !(0, shared_utils_1.isUndefined)(provider.useValue);\n  }\n\n  isCustomFactory(provider) {\n    return !(0, shared_utils_1.isUndefined)(provider.useFactory);\n  }\n\n  isCustomUseExisting(provider) {\n    return !(0, shared_utils_1.isUndefined)(provider.useExisting);\n  }\n\n  isDynamicModule(exported) {\n    return exported && exported.module;\n  }\n\n  addCustomClass(provider, collection) {\n    let {\n      scope\n    } = provider;\n    const {\n      useClass\n    } = provider;\n\n    if ((0, shared_utils_1.isUndefined)(scope)) {\n      scope = (0, get_class_scope_1.getClassScope)(useClass);\n    }\n\n    collection.set(provider.provide, new instance_wrapper_1.InstanceWrapper({\n      token: provider.provide,\n      name: (useClass === null || useClass === void 0 ? void 0 : useClass.name) || useClass,\n      metatype: useClass,\n      instance: null,\n      isResolved: false,\n      scope,\n      host: this\n    }));\n  }\n\n  addCustomValue(provider, collection) {\n    const {\n      useValue: value,\n      provide: providerToken\n    } = provider;\n    collection.set(providerToken, new instance_wrapper_1.InstanceWrapper({\n      token: providerToken,\n      name: (providerToken === null || providerToken === void 0 ? void 0 : providerToken.name) || providerToken,\n      metatype: null,\n      instance: value,\n      isResolved: true,\n      async: value instanceof Promise,\n      host: this\n    }));\n  }\n\n  addCustomFactory(provider, collection) {\n    const {\n      useFactory: factory,\n      inject,\n      scope,\n      provide: providerToken\n    } = provider;\n    collection.set(providerToken, new instance_wrapper_1.InstanceWrapper({\n      token: providerToken,\n      name: (providerToken === null || providerToken === void 0 ? void 0 : providerToken.name) || providerToken,\n      metatype: factory,\n      instance: null,\n      isResolved: false,\n      inject: inject || [],\n      scope,\n      host: this\n    }));\n  }\n\n  addCustomUseExisting(provider, collection) {\n    const {\n      useExisting,\n      provide: providerToken\n    } = provider;\n    collection.set(providerToken, new instance_wrapper_1.InstanceWrapper({\n      token: providerToken,\n      name: (providerToken === null || providerToken === void 0 ? void 0 : providerToken.name) || providerToken,\n      metatype: instance => instance,\n      instance: null,\n      isResolved: false,\n      inject: [useExisting],\n      host: this,\n      isAlias: true\n    }));\n  }\n\n  addExportedProvider(provider) {\n    const addExportedUnit = token => this._exports.add(this.validateExportedProvider(token));\n\n    if (this.isCustomProvider(provider)) {\n      return this.addCustomExportedProvider(provider);\n    } else if ((0, shared_utils_1.isString)(provider) || (0, shared_utils_1.isSymbol)(provider)) {\n      return addExportedUnit(provider);\n    } else if (this.isDynamicModule(provider)) {\n      const {\n        module: moduleClassRef\n      } = provider;\n      return addExportedUnit(moduleClassRef);\n    }\n\n    addExportedUnit(provider);\n  }\n\n  addCustomExportedProvider(provider) {\n    const provide = provider.provide;\n\n    if ((0, shared_utils_1.isString)(provide) || (0, shared_utils_1.isSymbol)(provide)) {\n      return this._exports.add(this.validateExportedProvider(provide));\n    }\n\n    this._exports.add(this.validateExportedProvider(provide));\n  }\n\n  validateExportedProvider(token) {\n    if (this._providers.has(token)) {\n      return token;\n    }\n\n    const imports = (0, iterare_1.iterate)(this._imports.values()).filter(item => !!item).map(({\n      metatype\n    }) => metatype).filter(metatype => !!metatype).toArray();\n\n    if (!imports.includes(token)) {\n      const {\n        name\n      } = this.metatype;\n      const providerName = (0, shared_utils_1.isFunction)(token) ? token.name : token;\n      throw new unknown_export_exception_1.UnknownExportException(providerName, name);\n    }\n\n    return token;\n  }\n\n  addController(controller) {\n    this._controllers.set(controller, new instance_wrapper_1.InstanceWrapper({\n      token: controller,\n      name: controller.name,\n      metatype: controller,\n      instance: null,\n      isResolved: false,\n      scope: (0, get_class_scope_1.getClassScope)(controller),\n      host: this\n    }));\n\n    this.assignControllerUniqueId(controller);\n  }\n\n  assignControllerUniqueId(controller) {\n    Object.defineProperty(controller, constants_1.CONTROLLER_ID_KEY, {\n      enumerable: false,\n      writable: false,\n      configurable: true,\n      value: (0, random_string_generator_util_1.randomStringGenerator)()\n    });\n  }\n\n  addRelatedModule(module) {\n    this._imports.add(module);\n  }\n\n  replace(toReplace, options) {\n    if (options.isProvider && this.hasProvider(toReplace)) {\n      const originalProvider = this._providers.get(toReplace);\n\n      return originalProvider.mergeWith(Object.assign({\n        provide: toReplace\n      }, options));\n    } else if (!options.isProvider && this.hasInjectable(toReplace)) {\n      const originalInjectable = this._injectables.get(toReplace);\n\n      return originalInjectable.mergeWith(Object.assign({\n        provide: toReplace\n      }, options));\n    }\n  }\n\n  hasProvider(token) {\n    return this._providers.has(token);\n  }\n\n  hasInjectable(token) {\n    return this._injectables.has(token);\n  }\n\n  getProviderByKey(name) {\n    return this._providers.get(name);\n  }\n\n  getNonAliasProviders() {\n    return [...this._providers].filter(([_, wrapper]) => !wrapper.isAlias);\n  }\n\n  createModuleReferenceType() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    return class extends module_ref_1.ModuleRef {\n      constructor() {\n        super(self.container);\n      }\n\n      get(typeOrToken, options = {\n        strict: true\n      }) {\n        return !(options && options.strict) ? this.find(typeOrToken) : this.find(typeOrToken, self);\n      }\n\n      resolve(typeOrToken, contextId = (0, context_id_factory_1.createContextId)(), options = {\n        strict: true\n      }) {\n        return this.resolvePerContext(typeOrToken, self, contextId, options);\n      }\n\n      create(type) {\n        var _this = this;\n\n        return _asyncToGenerator(function* () {\n          if (!(type && (0, shared_utils_1.isFunction)(type) && type.prototype)) {\n            throw new invalid_class_exception_1.InvalidClassException(type);\n          }\n\n          return _this.instantiateClass(type, self);\n        })();\n      }\n\n    };\n  }\n\n}\n\nexports.Module = Module;","map":null,"metadata":{},"sourceType":"script"}