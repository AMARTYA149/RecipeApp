{"ast":null,"code":"import { ValidationError } from './ValidationError';\nimport { ValidationTypes } from './ValidationTypes';\nimport { ValidationUtils } from './ValidationUtils';\nimport { isPromise, convertToArray } from '../utils';\nimport { getMetadataStorage } from '../metadata/MetadataStorage';\n/**\n * Executes validation over given object.\n */\n\nexport class ValidationExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(validator, validatorOptions) {\n    this.validator = validator;\n    this.validatorOptions = validatorOptions; // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    this.awaitingPromises = [];\n    this.ignoreAsyncValidations = false; // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    this.metadataStorage = getMetadataStorage();\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  execute(object, targetSchema, validationErrors) {\n    var _a;\n    /**\n     * If there is no metadata registered it means possibly the dependencies are not flatterned and\n     * more than one instance is used.\n     *\n     * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n     */\n\n\n    if (!this.metadataStorage.hasValidationMetaData && ((_a = this.validatorOptions) === null || _a === void 0 ? void 0 : _a.enableDebugMessages) === true) {\n      console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n    }\n\n    const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n    const strictGroups = this.validatorOptions && this.validatorOptions.strictGroups || false;\n    const always = this.validatorOptions && this.validatorOptions.always || false;\n    const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, always, strictGroups, groups);\n    const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n    if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n      const validationError = new ValidationError();\n      if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === undefined || this.validatorOptions.validationError.target === true) validationError.target = object;\n      validationError.value = undefined;\n      validationError.property = undefined;\n      validationError.children = [];\n      validationError.constraints = {\n        unknownValue: 'an unknown value was passed to the validate function'\n      };\n      validationErrors.push(validationError);\n      return;\n    }\n\n    if (this.validatorOptions && this.validatorOptions.whitelist) this.whitelist(object, groupedMetadatas, validationErrors); // General validation\n\n    Object.keys(groupedMetadatas).forEach(propertyName => {\n      const value = object[propertyName];\n      const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n      const metadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n      if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n        this.awaitingPromises.push(value.then(resolvedValue => {\n          this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n        }));\n      } else {\n        this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n      }\n    });\n  }\n\n  whitelist(object, groupedMetadatas, validationErrors) {\n    const notAllowedProperties = [];\n    Object.keys(object).forEach(propertyName => {\n      // does this property have no metadata?\n      if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0) notAllowedProperties.push(propertyName);\n    });\n\n    if (notAllowedProperties.length > 0) {\n      if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n        // throw errors\n        notAllowedProperties.forEach(property => {\n          const validationError = this.generateValidationError(object, object[property], property);\n          validationError.constraints = {\n            [ValidationTypes.WHITELIST]: `property ${property} should not exist`\n          };\n          validationError.children = undefined;\n          validationErrors.push(validationError);\n        });\n      } else {\n        // strip non allowed properties\n        notAllowedProperties.forEach(property => delete object[property]);\n      }\n    }\n  }\n\n  stripEmptyErrors(errors) {\n    return errors.filter(error => {\n      if (error.children) {\n        error.children = this.stripEmptyErrors(error.children);\n      }\n\n      if (Object.keys(error.constraints).length === 0) {\n        if (error.children.length === 0) {\n          return false;\n        } else {\n          delete error.constraints;\n        }\n      }\n\n      return true;\n    });\n  } // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n\n  performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors) {\n    const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n    const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n    const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n    const validationError = this.generateValidationError(object, value, propertyName);\n    validationErrors.push(validationError);\n    const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n\n    if (!canValidate) {\n      return;\n    } // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n\n\n    this.customValidations(object, value, definedMetadatas, validationError);\n    this.mapContexts(object, value, definedMetadatas, validationError);\n\n    if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n      return;\n    }\n\n    if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n      return;\n    }\n\n    if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n      return;\n    }\n\n    this.customValidations(object, value, customValidationMetadatas, validationError);\n    this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n    this.mapContexts(object, value, metadatas, validationError);\n    this.mapContexts(object, value, customValidationMetadatas, validationError);\n  }\n\n  generateValidationError(object, value, propertyName) {\n    const validationError = new ValidationError();\n    if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === undefined || this.validatorOptions.validationError.target === true) validationError.target = object;\n    if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.value === undefined || this.validatorOptions.validationError.value === true) validationError.value = value;\n    validationError.property = propertyName;\n    validationError.children = [];\n    validationError.constraints = {};\n    return validationError;\n  }\n\n  conditionalValidations(object, value, metadatas) {\n    return metadatas.map(metadata => metadata.constraints[0](object, value)).reduce((resultA, resultB) => resultA && resultB, true);\n  }\n\n  customValidations(object, value, metadatas, error) {\n    metadatas.forEach(metadata => {\n      this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls).forEach(customConstraintMetadata => {\n        if (customConstraintMetadata.async && this.ignoreAsyncValidations) return;\n        if (this.validatorOptions && this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0) return;\n        const validationArguments = {\n          targetName: object.constructor ? object.constructor.name : undefined,\n          property: metadata.propertyName,\n          object: object,\n          value: value,\n          constraints: metadata.constraints\n        };\n\n        if (!metadata.each || !(Array.isArray(value) || value instanceof Set || value instanceof Map)) {\n          const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n\n          if (isPromise(validatedValue)) {\n            const promise = validatedValue.then(isValid => {\n              if (!isValid) {\n                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                error.constraints[type] = message;\n\n                if (metadata.context) {\n                  if (!error.contexts) {\n                    error.contexts = {};\n                  }\n\n                  error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                }\n              }\n            });\n            this.awaitingPromises.push(promise);\n          } else {\n            if (!validatedValue) {\n              const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n              error.constraints[type] = message;\n            }\n          }\n\n          return;\n        } // convert set and map into array\n\n\n        const arrayValue = convertToArray(value); // Validation needs to be applied to each array item\n\n        const validatedSubValues = arrayValue.map(subValue => customConstraintMetadata.instance.validate(subValue, validationArguments));\n        const validationIsAsync = validatedSubValues.some(validatedSubValue => isPromise(validatedSubValue));\n\n        if (validationIsAsync) {\n          // Wrap plain values (if any) in promises, so that all are async\n          const asyncValidatedSubValues = validatedSubValues.map(validatedSubValue => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n          const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues).then(flatValidatedValues => {\n            const validationResult = flatValidatedValues.every(isValid => isValid);\n\n            if (!validationResult) {\n              const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n              error.constraints[type] = message;\n\n              if (metadata.context) {\n                if (!error.contexts) {\n                  error.contexts = {};\n                }\n\n                error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n              }\n            }\n          });\n          this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n          return;\n        }\n\n        const validationResult = validatedSubValues.every(isValid => isValid);\n\n        if (!validationResult) {\n          const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n          error.constraints[type] = message;\n        }\n      });\n    });\n  }\n\n  nestedValidations(value, metadatas, errors) {\n    if (value === void 0) {\n      return;\n    }\n\n    metadatas.forEach(metadata => {\n      if (metadata.type !== ValidationTypes.NESTED_VALIDATION && metadata.type !== ValidationTypes.PROMISE_VALIDATION) {\n        return;\n      }\n\n      if (Array.isArray(value) || value instanceof Set || value instanceof Map) {\n        // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n        const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n        arrayLikeValue.forEach((subValue, index) => {\n          this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n        });\n      } else if (value instanceof Object) {\n        const targetSchema = typeof metadata.target === 'string' ? metadata.target : metadata.target.name;\n        this.execute(value, targetSchema, errors);\n      } else {\n        const error = new ValidationError();\n        error.value = value;\n        error.property = metadata.propertyName;\n        error.target = metadata.target;\n        const [type, message] = this.createValidationError(metadata.target, value, metadata);\n        error.constraints = {\n          [type]: message\n        };\n        errors.push(error);\n      }\n    });\n  }\n\n  mapContexts(object, value, metadatas, error) {\n    return metadatas.forEach(metadata => {\n      if (metadata.context) {\n        let customConstraint;\n\n        if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n          const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n          customConstraint = customConstraints[0];\n        }\n\n        const type = this.getConstraintType(metadata, customConstraint);\n\n        if (error.constraints[type]) {\n          if (!error.contexts) {\n            error.contexts = {};\n          }\n\n          error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n        }\n      }\n    });\n  }\n\n  createValidationError(object, value, metadata, customValidatorMetadata) {\n    const targetName = object.constructor ? object.constructor.name : undefined;\n    const type = this.getConstraintType(metadata, customValidatorMetadata);\n    const validationArguments = {\n      targetName: targetName,\n      property: metadata.propertyName,\n      object: object,\n      value: value,\n      constraints: metadata.constraints\n    };\n    let message = metadata.message || '';\n\n    if (!metadata.message && (!this.validatorOptions || this.validatorOptions && !this.validatorOptions.dismissDefaultMessages)) {\n      if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n        message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n      }\n    }\n\n    const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n    return [type, messageString];\n  }\n\n  getConstraintType(metadata, customValidatorMetadata) {\n    const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n    return type;\n  }\n\n} //# sourceMappingURL=ValidationExecutor.js.map","map":null,"metadata":{},"sourceType":"module"}