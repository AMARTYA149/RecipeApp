{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SseStream = void 0;\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst stream_1 = require(\"stream\");\n\nfunction toDataString(data) {\n  if ((0, shared_utils_1.isObject)(data)) {\n    return toDataString(JSON.stringify(data));\n  }\n\n  return data.split(/\\r\\n|\\r|\\n/).map(line => `data: ${line}\\n`).join('');\n}\n/**\n * Adapted from https://raw.githubusercontent.com/EventSource/node-ssestream\n * Transforms \"messages\" to W3C event stream content.\n * See https://html.spec.whatwg.org/multipage/server-sent-events.html\n * A message is an object with one or more of the following properties:\n * - data (String or object, which gets turned into JSON)\n * - type\n * - id\n * - retry\n *\n * If constructed with a HTTP Request, it will optimise the socket for streaming.\n * If this stream is piped to an HTTP Response, it will set appropriate headers.\n */\n\n\nclass SseStream extends stream_1.Transform {\n  constructor(req) {\n    super({\n      objectMode: true\n    });\n    this.lastEventId = null;\n\n    if (req && req.socket) {\n      req.socket.setKeepAlive(true);\n      req.socket.setNoDelay(true);\n      req.socket.setTimeout(0);\n    }\n  }\n\n  pipe(destination, options) {\n    if (destination.writeHead) {\n      destination.writeHead(200, Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.additionalHeaders), {\n        // See https://github.com/dunglas/mercure/blob/master/hub/subscribe.go#L124-L130\n        'Content-Type': 'text/event-stream',\n        Connection: 'keep-alive',\n        // Disable cache, even for old browsers and proxies\n        'Cache-Control': 'private, no-cache, no-store, must-revalidate, max-age=0, no-transform',\n        Pragma: 'no-cache',\n        Expire: '0',\n        // NGINX support https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/#x-accel-buffering\n        'X-Accel-Buffering': 'no'\n      }));\n      destination.flushHeaders();\n    }\n\n    destination.write('\\n');\n    return super.pipe(destination, options);\n  }\n\n  _transform(message, encoding, callback) {\n    let data = message.type ? `event: ${message.type}\\n` : '';\n    data += message.id ? `id: ${message.id}\\n` : '';\n    data += message.retry ? `retry: ${message.retry}\\n` : '';\n    data += message.data ? toDataString(message.data) : '';\n    data += '\\n';\n    this.push(data);\n    callback();\n  }\n  /**\n   * Calls `.write` but handles the drain if needed\n   */\n\n\n  writeMessage(message, cb) {\n    if (!message.id) {\n      this.lastEventId++;\n      message.id = this.lastEventId.toString();\n    }\n\n    if (!this.write(message, 'utf-8', cb)) {\n      this.once('drain', cb);\n    } else {\n      process.nextTick(cb);\n    }\n  }\n\n}\n\nexports.SseStream = SseStream;","map":null,"metadata":{},"sourceType":"script"}