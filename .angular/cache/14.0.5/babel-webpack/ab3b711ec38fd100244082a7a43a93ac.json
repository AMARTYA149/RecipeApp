{"ast":null,"code":"import { ValidationSchemaToMetadataTransformer } from '../validation-schema/ValidationSchemaToMetadataTransformer';\nimport { getGlobal } from '../utils';\n/**\n * Storage all metadatas.\n */\n\nexport class MetadataStorage {\n  constructor() {\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n    this.validationMetadatas = [];\n    this.constraintMetadatas = [];\n  }\n\n  get hasValidationMetaData() {\n    return !!this.validationMetadatas.length;\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Adds a new validation metadata.\n   */\n\n\n  addValidationSchema(schema) {\n    const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n    validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n  }\n  /**\n   * Adds a new validation metadata.\n   */\n\n\n  addValidationMetadata(metadata) {\n    this.validationMetadatas.push(metadata);\n  }\n  /**\n   * Adds a new constraint metadata.\n   */\n\n\n  addConstraintMetadata(metadata) {\n    this.constraintMetadatas.push(metadata);\n  }\n  /**\n   * Groups metadata by their property names.\n   */\n\n\n  groupByPropertyName(metadata) {\n    const grouped = {};\n    metadata.forEach(metadata => {\n      if (!grouped[metadata.propertyName]) grouped[metadata.propertyName] = [];\n      grouped[metadata.propertyName].push(metadata);\n    });\n    return grouped;\n  }\n  /**\n   * Gets all validation metadatas for the given object with the given groups.\n   */\n\n\n  getTargetValidationMetadatas(targetConstructor, targetSchema, always, strictGroups, groups) {\n    const includeMetadataBecauseOfAlwaysOption = metadata => {\n      // `metadata.always` overrides global default.\n      if (typeof metadata.always !== 'undefined') return metadata.always; // `metadata.groups` overrides global default.\n\n      if (metadata.groups && metadata.groups.length) return false; // Use global default.\n\n      return always;\n    };\n\n    const excludeMetadataBecauseOfStrictGroupsOption = metadata => {\n      if (strictGroups) {\n        // Validation is not using groups.\n        if (!groups || !groups.length) {\n          // `metadata.groups` has at least one group.\n          if (metadata.groups && metadata.groups.length) return true;\n        }\n      }\n\n      return false;\n    }; // get directly related to a target metadatas\n\n\n    const originalMetadatas = this.validationMetadatas.filter(metadata => {\n      if (metadata.target !== targetConstructor && metadata.target !== targetSchema) return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0) return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n      return true;\n    }); // get metadatas for inherited classes\n\n    const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n      // if target is a string it's means we validate against a schema, and there is no inheritance support for schemas\n      if (typeof metadata.target === 'string') return false;\n      if (metadata.target === targetConstructor) return false;\n      if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target)) return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0) return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n      return true;\n    }); // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n\n    const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n      return !originalMetadatas.find(originalMetadata => {\n        return originalMetadata.propertyName === inheritedMetadata.propertyName && originalMetadata.type === inheritedMetadata.type;\n      });\n    });\n    return originalMetadatas.concat(uniqueInheritedMetadatas);\n  }\n  /**\n   * Gets all validator constraints for the given object.\n   */\n\n\n  getTargetValidatorConstraints(target) {\n    return this.constraintMetadatas.filter(metadata => metadata.target === target);\n  }\n\n}\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\n\nexport function getMetadataStorage() {\n  const global = getGlobal();\n\n  if (!global.classValidatorMetadataStorage) {\n    global.classValidatorMetadataStorage = new MetadataStorage();\n  }\n\n  return global.classValidatorMetadataStorage;\n} //# sourceMappingURL=MetadataStorage.js.map","map":null,"metadata":{},"sourceType":"module"}