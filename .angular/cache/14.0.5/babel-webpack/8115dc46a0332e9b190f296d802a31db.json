{"ast":null,"code":"'use strict';\n\nfunction parseContentType(str) {\n  if (str.length === 0) return;\n  const params = Object.create(null);\n  let i = 0; // Parse type\n\n  for (; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n\n    if (TOKEN[code] !== 1) {\n      if (code !== 47\n      /* '/' */\n      || i === 0) return;\n      break;\n    }\n  } // Check for type without subtype\n\n\n  if (i === str.length) return;\n  const type = str.slice(0, i).toLowerCase(); // Parse subtype\n\n  const subtypeStart = ++i;\n\n  for (; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n\n    if (TOKEN[code] !== 1) {\n      // Make sure we have a subtype\n      if (i === subtypeStart) return;\n      if (parseContentTypeParams(str, i, params) === undefined) return;\n      break;\n    }\n  } // Make sure we have a subtype\n\n\n  if (i === subtypeStart) return;\n  const subtype = str.slice(subtypeStart, i).toLowerCase();\n  return {\n    type,\n    subtype,\n    params\n  };\n}\n\nfunction parseContentTypeParams(str, i, params) {\n  while (i < str.length) {\n    // Consume whitespace\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32\n      /* ' ' */\n      && code !== 9\n      /* '\\t' */\n      ) break;\n    } // Ended on whitespace\n\n\n    if (i === str.length) break; // Check for malformed parameter\n\n    if (str.charCodeAt(i++) !== 59\n    /* ';' */\n    ) return; // Consume whitespace\n\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32\n      /* ' ' */\n      && code !== 9\n      /* '\\t' */\n      ) break;\n    } // Ended on whitespace (malformed)\n\n\n    if (i === str.length) return;\n    let name;\n    const nameStart = i; // Parse parameter name\n\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n\n      if (TOKEN[code] !== 1) {\n        if (code !== 61\n        /* '=' */\n        ) return;\n        break;\n      }\n    } // No value (malformed)\n\n\n    if (i === str.length) return;\n    name = str.slice(nameStart, i);\n    ++i; // Skip over '='\n    // No value (malformed)\n\n    if (i === str.length) return;\n    let value = '';\n    let valueStart;\n\n    if (str.charCodeAt(i) === 34\n    /* '\"' */\n    ) {\n      valueStart = ++i;\n      let escaping = false; // Parse quoted value\n\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n\n        if (code === 92\n        /* '\\\\' */\n        ) {\n          if (escaping) {\n            valueStart = i;\n            escaping = false;\n          } else {\n            value += str.slice(valueStart, i);\n            escaping = true;\n          }\n\n          continue;\n        }\n\n        if (code === 34\n        /* '\"' */\n        ) {\n          if (escaping) {\n            valueStart = i;\n            escaping = false;\n            continue;\n          }\n\n          value += str.slice(valueStart, i);\n          break;\n        }\n\n        if (escaping) {\n          valueStart = i - 1;\n          escaping = false;\n        } // Invalid unescaped quoted character (malformed)\n\n\n        if (QDTEXT[code] !== 1) return;\n      } // No end quote (malformed)\n\n\n      if (i === str.length) return;\n      ++i; // Skip over double quote\n    } else {\n      valueStart = i; // Parse unquoted value\n\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n\n        if (TOKEN[code] !== 1) {\n          // No value (malformed)\n          if (i === valueStart) return;\n          break;\n        }\n      }\n\n      value = str.slice(valueStart, i);\n    }\n\n    name = name.toLowerCase();\n    if (params[name] === undefined) params[name] = value;\n  }\n\n  return params;\n}\n\nfunction parseDisposition(str, defDecoder) {\n  if (str.length === 0) return;\n  const params = Object.create(null);\n  let i = 0;\n\n  for (; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n\n    if (TOKEN[code] !== 1) {\n      if (parseDispositionParams(str, i, params, defDecoder) === undefined) return;\n      break;\n    }\n  }\n\n  const type = str.slice(0, i).toLowerCase();\n  return {\n    type,\n    params\n  };\n}\n\nfunction parseDispositionParams(str, i, params, defDecoder) {\n  while (i < str.length) {\n    // Consume whitespace\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32\n      /* ' ' */\n      && code !== 9\n      /* '\\t' */\n      ) break;\n    } // Ended on whitespace\n\n\n    if (i === str.length) break; // Check for malformed parameter\n\n    if (str.charCodeAt(i++) !== 59\n    /* ';' */\n    ) return; // Consume whitespace\n\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32\n      /* ' ' */\n      && code !== 9\n      /* '\\t' */\n      ) break;\n    } // Ended on whitespace (malformed)\n\n\n    if (i === str.length) return;\n    let name;\n    const nameStart = i; // Parse parameter name\n\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n\n      if (TOKEN[code] !== 1) {\n        if (code === 61\n        /* '=' */\n        ) break;\n        return;\n      }\n    } // No value (malformed)\n\n\n    if (i === str.length) return;\n    let value = '';\n    let valueStart;\n    let charset; //~ let lang;\n\n    name = str.slice(nameStart, i);\n\n    if (name.charCodeAt(name.length - 1) === 42\n    /* '*' */\n    ) {\n      // Extended value\n      const charsetStart = ++i; // Parse charset name\n\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n\n        if (CHARSET[code] !== 1) {\n          if (code !== 39\n          /* '\\'' */\n          ) return;\n          break;\n        }\n      } // Incomplete charset (malformed)\n\n\n      if (i === str.length) return;\n      charset = str.slice(charsetStart, i);\n      ++i; // Skip over the '\\''\n      //~ const langStart = ++i;\n      // Parse language name\n\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (code === 39\n        /* '\\'' */\n        ) break;\n      } // Incomplete language (malformed)\n\n\n      if (i === str.length) return; //~ lang = str.slice(langStart, i);\n\n      ++i; // Skip over the '\\''\n      // No value (malformed)\n\n      if (i === str.length) return;\n      valueStart = i;\n      let encode = 0; // Parse value\n\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n\n        if (EXTENDED_VALUE[code] !== 1) {\n          if (code === 37\n          /* '%' */\n          ) {\n            let hexUpper;\n            let hexLower;\n\n            if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {\n              const byteVal = (hexUpper << 4) + hexLower;\n              value += str.slice(valueStart, i);\n              value += String.fromCharCode(byteVal);\n              i += 2;\n              valueStart = i + 1;\n              if (byteVal >= 128) encode = 2;else if (encode === 0) encode = 1;\n              continue;\n            } // '%' disallowed in non-percent encoded contexts (malformed)\n\n\n            return;\n          }\n\n          break;\n        }\n      }\n\n      value += str.slice(valueStart, i);\n      value = convertToUTF8(value, charset, encode);\n      if (value === undefined) return;\n    } else {\n      // Non-extended value\n      ++i; // Skip over '='\n      // No value (malformed)\n\n      if (i === str.length) return;\n\n      if (str.charCodeAt(i) === 34\n      /* '\"' */\n      ) {\n        valueStart = ++i;\n        let escaping = false; // Parse quoted value\n\n        for (; i < str.length; ++i) {\n          const code = str.charCodeAt(i);\n\n          if (code === 92\n          /* '\\\\' */\n          ) {\n            if (escaping) {\n              valueStart = i;\n              escaping = false;\n            } else {\n              value += str.slice(valueStart, i);\n              escaping = true;\n            }\n\n            continue;\n          }\n\n          if (code === 34\n          /* '\"' */\n          ) {\n            if (escaping) {\n              valueStart = i;\n              escaping = false;\n              continue;\n            }\n\n            value += str.slice(valueStart, i);\n            break;\n          }\n\n          if (escaping) {\n            valueStart = i - 1;\n            escaping = false;\n          } // Invalid unescaped quoted character (malformed)\n\n\n          if (QDTEXT[code] !== 1) return;\n        } // No end quote (malformed)\n\n\n        if (i === str.length) return;\n        ++i; // Skip over double quote\n      } else {\n        valueStart = i; // Parse unquoted value\n\n        for (; i < str.length; ++i) {\n          const code = str.charCodeAt(i);\n\n          if (TOKEN[code] !== 1) {\n            // No value (malformed)\n            if (i === valueStart) return;\n            break;\n          }\n        }\n\n        value = str.slice(valueStart, i);\n      }\n\n      value = defDecoder(value, 2);\n      if (value === undefined) return;\n    }\n\n    name = name.toLowerCase();\n    if (params[name] === undefined) params[name] = value;\n  }\n\n  return params;\n}\n\nfunction getDecoder(charset) {\n  let lc;\n\n  while (true) {\n    switch (charset) {\n      case 'utf-8':\n      case 'utf8':\n        return decoders.utf8;\n\n      case 'latin1':\n      case 'ascii': // TODO: Make these a separate, strict decoder?\n\n      case 'us-ascii':\n      case 'iso-8859-1':\n      case 'iso8859-1':\n      case 'iso88591':\n      case 'iso_8859-1':\n      case 'windows-1252':\n      case 'iso_8859-1:1987':\n      case 'cp1252':\n      case 'x-cp1252':\n        return decoders.latin1;\n\n      case 'utf16le':\n      case 'utf-16le':\n      case 'ucs2':\n      case 'ucs-2':\n        return decoders.utf16le;\n\n      case 'base64':\n        return decoders.base64;\n\n      default:\n        if (lc === undefined) {\n          lc = true;\n          charset = charset.toLowerCase();\n          continue;\n        }\n\n        return decoders.other.bind(charset);\n    }\n  }\n}\n\nconst decoders = {\n  utf8: (data, hint) => {\n    if (data.length === 0) return '';\n\n    if (typeof data === 'string') {\n      // If `data` never had any percent-encoded bytes or never had any that\n      // were outside of the ASCII range, then we can safely just return the\n      // input since UTF-8 is ASCII compatible\n      if (hint < 2) return data;\n      data = Buffer.from(data, 'latin1');\n    }\n\n    return data.utf8Slice(0, data.length);\n  },\n  latin1: (data, hint) => {\n    if (data.length === 0) return '';\n    if (typeof data === 'string') return data;\n    return data.latin1Slice(0, data.length);\n  },\n  utf16le: (data, hint) => {\n    if (data.length === 0) return '';\n    if (typeof data === 'string') data = Buffer.from(data, 'latin1');\n    return data.ucs2Slice(0, data.length);\n  },\n  base64: (data, hint) => {\n    if (data.length === 0) return '';\n    if (typeof data === 'string') data = Buffer.from(data, 'latin1');\n    return data.base64Slice(0, data.length);\n  },\n  other: (data, hint) => {\n    if (data.length === 0) return '';\n    if (typeof data === 'string') data = Buffer.from(data, 'latin1');\n\n    try {\n      const decoder = new TextDecoder(this);\n      return decoder.decode(data);\n    } catch {}\n  }\n};\n\nfunction convertToUTF8(data, charset, hint) {\n  const decode = getDecoder(charset);\n  if (decode) return decode(data, hint);\n}\n\nfunction basename(path) {\n  if (typeof path !== 'string') return '';\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    switch (path.charCodeAt(i)) {\n      case 0x2F: // '/'\n\n      case 0x5C:\n        // '\\'\n        path = path.slice(i + 1);\n        return path === '..' || path === '.' ? '' : path;\n    }\n  }\n\n  return path === '..' || path === '.' ? '' : path;\n}\n\nconst TOKEN = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nconst QDTEXT = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nconst CHARSET = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nconst EXTENDED_VALUE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n/* eslint-disable no-multi-spaces */\n\nconst HEX_VALUES = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n/* eslint-enable no-multi-spaces */\n\nmodule.exports = {\n  basename,\n  convertToUTF8,\n  getDecoder,\n  parseContentType,\n  parseDisposition\n};","map":null,"metadata":{},"sourceType":"script"}