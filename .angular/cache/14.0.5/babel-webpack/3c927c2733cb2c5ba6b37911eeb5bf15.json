{"ast":null,"code":"'use strict';\n\nconst {\n  Readable,\n  Writable\n} = require('stream');\n\nconst StreamSearch = require('streamsearch');\n\nconst {\n  basename,\n  convertToUTF8,\n  getDecoder,\n  parseContentType,\n  parseDisposition\n} = require('../utils.js');\n\nconst BUF_CRLF = Buffer.from('\\r\\n');\nconst BUF_CR = Buffer.from('\\r');\nconst BUF_DASH = Buffer.from('-');\n\nfunction noop() {}\n\nconst MAX_HEADER_PAIRS = 2000; // From node\n\nconst MAX_HEADER_SIZE = 16 * 1024; // From node (its default value)\n\nconst HPARSER_NAME = 0;\nconst HPARSER_PRE_OWS = 1;\nconst HPARSER_VALUE = 2;\n\nclass HeaderParser {\n  constructor(cb) {\n    this.header = Object.create(null);\n    this.pairCount = 0;\n    this.byteCount = 0;\n    this.state = HPARSER_NAME;\n    this.name = '';\n    this.value = '';\n    this.crlf = 0;\n    this.cb = cb;\n  }\n\n  reset() {\n    this.header = Object.create(null);\n    this.pairCount = 0;\n    this.byteCount = 0;\n    this.state = HPARSER_NAME;\n    this.name = '';\n    this.value = '';\n    this.crlf = 0;\n  }\n\n  push(chunk, pos, end) {\n    let start = pos;\n\n    while (pos < end) {\n      switch (this.state) {\n        case HPARSER_NAME:\n          {\n            let done = false;\n\n            for (; pos < end; ++pos) {\n              if (this.byteCount === MAX_HEADER_SIZE) return -1;\n              ++this.byteCount;\n              const code = chunk[pos];\n\n              if (TOKEN[code] !== 1) {\n                if (code !== 58\n                /* ':' */\n                ) return -1;\n                this.name += chunk.latin1Slice(start, pos);\n                if (this.name.length === 0) return -1;\n                ++pos;\n                done = true;\n                this.state = HPARSER_PRE_OWS;\n                break;\n              }\n            }\n\n            if (!done) {\n              this.name += chunk.latin1Slice(start, pos);\n              break;\n            } // FALLTHROUGH\n\n          }\n\n        case HPARSER_PRE_OWS:\n          {\n            // Skip optional whitespace\n            let done = false;\n\n            for (; pos < end; ++pos) {\n              if (this.byteCount === MAX_HEADER_SIZE) return -1;\n              ++this.byteCount;\n              const code = chunk[pos];\n\n              if (code !== 32\n              /* ' ' */\n              && code !== 9\n              /* '\\t' */\n              ) {\n                start = pos;\n                done = true;\n                this.state = HPARSER_VALUE;\n                break;\n              }\n            }\n\n            if (!done) break; // FALLTHROUGH\n          }\n\n        case HPARSER_VALUE:\n          switch (this.crlf) {\n            case 0:\n              // Nothing yet\n              for (; pos < end; ++pos) {\n                if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                ++this.byteCount;\n                const code = chunk[pos];\n\n                if (FIELD_VCHAR[code] !== 1) {\n                  if (code !== 13\n                  /* '\\r' */\n                  ) return -1;\n                  ++this.crlf;\n                  break;\n                }\n              }\n\n              this.value += chunk.latin1Slice(start, pos++);\n              break;\n\n            case 1:\n              // Received CR\n              if (this.byteCount === MAX_HEADER_SIZE) return -1;\n              ++this.byteCount;\n              if (chunk[pos++] !== 10\n              /* '\\n' */\n              ) return -1;\n              ++this.crlf;\n              break;\n\n            case 2:\n              {\n                // Received CR LF\n                if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                ++this.byteCount;\n                const code = chunk[pos];\n\n                if (code === 32\n                /* ' ' */\n                || code === 9\n                /* '\\t' */\n                ) {\n                  // Folded value\n                  start = pos;\n                  this.crlf = 0;\n                } else {\n                  if (++this.pairCount < MAX_HEADER_PAIRS) {\n                    this.name = this.name.toLowerCase();\n                    if (this.header[this.name] === undefined) this.header[this.name] = [this.value];else this.header[this.name].push(this.value);\n                  }\n\n                  if (code === 13\n                  /* '\\r' */\n                  ) {\n                    ++this.crlf;\n                    ++pos;\n                  } else {\n                    // Assume start of next header field name\n                    start = pos;\n                    this.crlf = 0;\n                    this.state = HPARSER_NAME;\n                    this.name = '';\n                    this.value = '';\n                  }\n                }\n\n                break;\n              }\n\n            case 3:\n              {\n                // Received CR LF CR\n                if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                ++this.byteCount;\n                if (chunk[pos++] !== 10\n                /* '\\n' */\n                ) return -1; // End of header\n\n                const header = this.header;\n                this.reset();\n                this.cb(header);\n                return pos;\n              }\n          }\n\n          break;\n      }\n    }\n\n    return pos;\n  }\n\n}\n\nclass FileStream extends Readable {\n  constructor(opts, owner) {\n    super(opts);\n    this.truncated = false;\n    this._readcb = null;\n    this.once('end', () => {\n      // We need to make sure that we call any outstanding _writecb() that is\n      // associated with this file so that processing of the rest of the form\n      // can continue. This may not happen if the file stream ends right after\n      // backpressure kicks in, so we force it here.\n      this._read();\n\n      if (--owner._fileEndsLeft === 0 && owner._finalcb) {\n        const cb = owner._finalcb;\n        owner._finalcb = null; // Make sure other 'end' event handlers get a chance to be executed\n        // before busboy's 'finish' event is emitted\n\n        process.nextTick(cb);\n      }\n    });\n  }\n\n  _read(n) {\n    const cb = this._readcb;\n\n    if (cb) {\n      this._readcb = null;\n      cb();\n    }\n  }\n\n}\n\nconst ignoreData = {\n  push: (chunk, pos) => {},\n  destroy: () => {}\n};\n\nfunction callAndUnsetCb(self, err) {\n  const cb = self._writecb;\n  self._writecb = null;\n  if (err) self.destroy(err);else if (cb) cb();\n}\n\nfunction nullDecoder(val, hint) {\n  return val;\n}\n\nclass Multipart extends Writable {\n  constructor(cfg) {\n    const streamOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: typeof cfg.highWaterMark === 'number' ? cfg.highWaterMark : undefined\n    };\n    super(streamOpts);\n    if (!cfg.conType.params || typeof cfg.conType.params.boundary !== 'string') throw new Error('Multipart: Boundary not found');\n    const boundary = cfg.conType.params.boundary;\n    const paramDecoder = typeof cfg.defParamCharset === 'string' && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;\n    const defCharset = cfg.defCharset || 'utf8';\n    const preservePath = cfg.preservePath;\n    const fileOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: typeof cfg.fileHwm === 'number' ? cfg.fileHwm : undefined\n    };\n    const limits = cfg.limits;\n    const fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;\n    const fileSizeLimit = limits && typeof limits.fileSize === 'number' ? limits.fileSize : Infinity;\n    const filesLimit = limits && typeof limits.files === 'number' ? limits.files : Infinity;\n    const fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;\n    const partsLimit = limits && typeof limits.parts === 'number' ? limits.parts : Infinity;\n    let parts = -1; // Account for initial boundary\n\n    let fields = 0;\n    let files = 0;\n    let skipPart = false;\n    this._fileEndsLeft = 0;\n    this._fileStream = undefined;\n    this._complete = false;\n    let fileSize = 0;\n    let field;\n    let fieldSize = 0;\n    let partCharset;\n    let partEncoding;\n    let partType;\n    let partName;\n    let partTruncated = false;\n    let hitFilesLimit = false;\n    let hitFieldsLimit = false;\n    this._hparser = null;\n    const hparser = new HeaderParser(header => {\n      this._hparser = null;\n      skipPart = false;\n      partType = 'text/plain';\n      partCharset = defCharset;\n      partEncoding = '7bit';\n      partName = undefined;\n      partTruncated = false;\n      let filename;\n\n      if (!header['content-disposition']) {\n        skipPart = true;\n        return;\n      }\n\n      const disp = parseDisposition(header['content-disposition'][0], paramDecoder);\n\n      if (!disp || disp.type !== 'form-data') {\n        skipPart = true;\n        return;\n      }\n\n      if (disp.params) {\n        if (disp.params.name) partName = disp.params.name;\n        if (disp.params['filename*']) filename = disp.params['filename*'];else if (disp.params.filename) filename = disp.params.filename;\n        if (filename !== undefined && !preservePath) filename = basename(filename);\n      }\n\n      if (header['content-type']) {\n        const conType = parseContentType(header['content-type'][0]);\n\n        if (conType) {\n          partType = `${conType.type}/${conType.subtype}`;\n          if (conType.params && typeof conType.params.charset === 'string') partCharset = conType.params.charset.toLowerCase();\n        }\n      }\n\n      if (header['content-transfer-encoding']) partEncoding = header['content-transfer-encoding'][0].toLowerCase();\n\n      if (partType === 'application/octet-stream' || filename !== undefined) {\n        // File\n        if (files === filesLimit) {\n          if (!hitFilesLimit) {\n            hitFilesLimit = true;\n            this.emit('filesLimit');\n          }\n\n          skipPart = true;\n          return;\n        }\n\n        ++files;\n\n        if (this.listenerCount('file') === 0) {\n          skipPart = true;\n          return;\n        }\n\n        fileSize = 0;\n        this._fileStream = new FileStream(fileOpts, this);\n        ++this._fileEndsLeft;\n        this.emit('file', partName, this._fileStream, {\n          filename,\n          encoding: partEncoding,\n          mimeType: partType\n        });\n      } else {\n        // Non-file\n        if (fields === fieldsLimit) {\n          if (!hitFieldsLimit) {\n            hitFieldsLimit = true;\n            this.emit('fieldsLimit');\n          }\n\n          skipPart = true;\n          return;\n        }\n\n        ++fields;\n\n        if (this.listenerCount('field') === 0) {\n          skipPart = true;\n          return;\n        }\n\n        field = [];\n        fieldSize = 0;\n      }\n    });\n    let matchPostBoundary = 0;\n\n    const ssCb = (isMatch, data, start, end, isDataSafe) => {\n      retrydata: while (data) {\n        if (this._hparser !== null) {\n          const ret = this._hparser.push(data, start, end);\n\n          if (ret === -1) {\n            this._hparser = null;\n            hparser.reset();\n            this.emit('error', new Error('Malformed part header'));\n            break;\n          }\n\n          start = ret;\n        }\n\n        if (start === end) break;\n\n        if (matchPostBoundary !== 0) {\n          if (matchPostBoundary === 1) {\n            switch (data[start]) {\n              case 45:\n                // '-'\n                // Try matching '--' after boundary\n                matchPostBoundary = 2;\n                ++start;\n                break;\n\n              case 13:\n                // '\\r'\n                // Try matching CR LF before header\n                matchPostBoundary = 3;\n                ++start;\n                break;\n\n              default:\n                matchPostBoundary = 0;\n            }\n\n            if (start === end) return;\n          }\n\n          if (matchPostBoundary === 2) {\n            matchPostBoundary = 0;\n\n            if (data[start] === 45\n            /* '-' */\n            ) {\n              // End of multipart data\n              this._complete = true;\n              this._bparser = ignoreData;\n              return;\n            } // We saw something other than '-', so put the dash we consumed\n            // \"back\"\n\n\n            const writecb = this._writecb;\n            this._writecb = noop;\n            ssCb(false, BUF_DASH, 0, 1, false);\n            this._writecb = writecb;\n          } else if (matchPostBoundary === 3) {\n            matchPostBoundary = 0;\n\n            if (data[start] === 10\n            /* '\\n' */\n            ) {\n              ++start;\n              if (parts >= partsLimit) break; // Prepare the header parser\n\n              this._hparser = hparser;\n              if (start === end) break; // Process the remaining data as a header\n\n              continue retrydata;\n            } else {\n              // We saw something other than LF, so put the CR we consumed\n              // \"back\"\n              const writecb = this._writecb;\n              this._writecb = noop;\n              ssCb(false, BUF_CR, 0, 1, false);\n              this._writecb = writecb;\n            }\n          }\n        }\n\n        if (!skipPart) {\n          if (this._fileStream) {\n            let chunk;\n            const actualLen = Math.min(end - start, fileSizeLimit - fileSize);\n\n            if (!isDataSafe) {\n              chunk = Buffer.allocUnsafe(actualLen);\n              data.copy(chunk, 0, start, start + actualLen);\n            } else {\n              chunk = data.slice(start, start + actualLen);\n            }\n\n            fileSize += chunk.length;\n\n            if (fileSize === fileSizeLimit) {\n              if (chunk.length > 0) this._fileStream.push(chunk);\n\n              this._fileStream.emit('limit');\n\n              this._fileStream.truncated = true;\n              skipPart = true;\n            } else if (!this._fileStream.push(chunk)) {\n              if (this._writecb) this._fileStream._readcb = this._writecb;\n              this._writecb = null;\n            }\n          } else if (field !== undefined) {\n            let chunk;\n            const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);\n\n            if (!isDataSafe) {\n              chunk = Buffer.allocUnsafe(actualLen);\n              data.copy(chunk, 0, start, start + actualLen);\n            } else {\n              chunk = data.slice(start, start + actualLen);\n            }\n\n            fieldSize += actualLen;\n            field.push(chunk);\n\n            if (fieldSize === fieldSizeLimit) {\n              skipPart = true;\n              partTruncated = true;\n            }\n          }\n        }\n\n        break;\n      }\n\n      if (isMatch) {\n        matchPostBoundary = 1;\n\n        if (this._fileStream) {\n          // End the active file stream if the previous part was a file\n          this._fileStream.push(null);\n\n          this._fileStream = null;\n        } else if (field !== undefined) {\n          let data;\n\n          switch (field.length) {\n            case 0:\n              data = '';\n              break;\n\n            case 1:\n              data = convertToUTF8(field[0], partCharset, 0);\n              break;\n\n            default:\n              data = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);\n          }\n\n          field = undefined;\n          fieldSize = 0;\n          this.emit('field', partName, data, {\n            nameTruncated: false,\n            valueTruncated: partTruncated,\n            encoding: partEncoding,\n            mimeType: partType\n          });\n        }\n\n        if (++parts === partsLimit) this.emit('partsLimit');\n      }\n    };\n\n    this._bparser = new StreamSearch(`\\r\\n--${boundary}`, ssCb);\n    this._writecb = null;\n    this._finalcb = null; // Just in case there is no preamble\n\n    this.write(BUF_CRLF);\n  }\n\n  static detect(conType) {\n    return conType.type === 'multipart' && conType.subtype === 'form-data';\n  }\n\n  _write(chunk, enc, cb) {\n    this._writecb = cb;\n\n    this._bparser.push(chunk, 0);\n\n    if (this._writecb) callAndUnsetCb(this);\n  }\n\n  _destroy(err, cb) {\n    this._hparser = null;\n    this._bparser = ignoreData;\n    if (!err) err = checkEndState(this);\n    const fileStream = this._fileStream;\n\n    if (fileStream) {\n      this._fileStream = null;\n      fileStream.destroy(err);\n    }\n\n    cb(err);\n  }\n\n  _final(cb) {\n    this._bparser.destroy();\n\n    if (!this._complete) return cb(new Error('Unexpected end of form'));\n    if (this._fileEndsLeft) this._finalcb = finalcb.bind(null, this, cb);else finalcb(this, cb);\n  }\n\n}\n\nfunction finalcb(self, cb, err) {\n  if (err) return cb(err);\n  err = checkEndState(self);\n  cb(err);\n}\n\nfunction checkEndState(self) {\n  if (self._hparser) return new Error('Malformed part header');\n  const fileStream = self._fileStream;\n\n  if (fileStream) {\n    self._fileStream = null;\n    fileStream.destroy(new Error('Unexpected end of file'));\n  }\n\n  if (!self._complete) return new Error('Unexpected end of form');\n}\n\nconst TOKEN = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nconst FIELD_VCHAR = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nmodule.exports = Multipart;","map":null,"metadata":{},"sourceType":"script"}