{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RoutesResolver = void 0;\n\nconst common_1 = require(\"@nestjs/common\");\n\nconst constants_1 = require(\"@nestjs/common/constants\");\n\nconst logger_service_1 = require(\"@nestjs/common/services/logger.service\");\n\nconst messages_1 = require(\"../helpers/messages\");\n\nconst metadata_scanner_1 = require(\"../metadata-scanner\");\n\nconst route_path_factory_1 = require(\"./route-path-factory\");\n\nconst router_exception_filters_1 = require(\"./router-exception-filters\");\n\nconst router_explorer_1 = require(\"./router-explorer\");\n\nconst router_proxy_1 = require(\"./router-proxy\");\n\nclass RoutesResolver {\n  constructor(container, applicationConfig, injector) {\n    this.container = container;\n    this.applicationConfig = applicationConfig;\n    this.injector = injector;\n    this.logger = new logger_service_1.Logger(RoutesResolver.name, {\n      timestamp: true\n    });\n    this.routerProxy = new router_proxy_1.RouterProxy();\n    const httpAdapterRef = container.getHttpAdapterRef();\n    this.routerExceptionsFilter = new router_exception_filters_1.RouterExceptionFilters(container, applicationConfig, httpAdapterRef);\n    this.routePathFactory = new route_path_factory_1.RoutePathFactory(this.applicationConfig);\n    const metadataScanner = new metadata_scanner_1.MetadataScanner();\n    this.routerExplorer = new router_explorer_1.RouterExplorer(metadataScanner, this.container, this.injector, this.routerProxy, this.routerExceptionsFilter, this.applicationConfig, this.routePathFactory);\n  }\n\n  resolve(applicationRef, globalPrefix) {\n    const modules = this.container.getModules();\n    modules.forEach(({\n      controllers,\n      metatype\n    }, moduleName) => {\n      const modulePath = this.getModulePathMetadata(metatype);\n      this.registerRouters(controllers, moduleName, globalPrefix, modulePath, applicationRef);\n    });\n  }\n\n  registerRouters(routes, moduleName, globalPrefix, modulePath, applicationRef) {\n    routes.forEach(instanceWrapper => {\n      const {\n        metatype\n      } = instanceWrapper;\n      const host = this.getHostMetadata(metatype);\n      const routerPaths = this.routerExplorer.extractRouterPath(metatype);\n      const controllerVersion = this.getVersionMetadata(metatype);\n      const controllerName = metatype.name;\n      routerPaths.forEach(path => {\n        const pathsToLog = this.routePathFactory.create({\n          ctrlPath: path,\n          modulePath,\n          globalPrefix\n        });\n\n        if (!controllerVersion) {\n          pathsToLog.forEach(path => {\n            const logMessage = (0, messages_1.CONTROLLER_MAPPING_MESSAGE)(controllerName, path);\n            this.logger.log(logMessage);\n          });\n        } else {\n          pathsToLog.forEach(path => {\n            const logMessage = (0, messages_1.VERSIONED_CONTROLLER_MAPPING_MESSAGE)(controllerName, path, controllerVersion);\n            this.logger.log(logMessage);\n          });\n        }\n\n        const versioningOptions = this.applicationConfig.getVersioning();\n        const routePathMetadata = {\n          ctrlPath: path,\n          modulePath,\n          globalPrefix,\n          controllerVersion,\n          versioningOptions\n        };\n        this.routerExplorer.explore(instanceWrapper, moduleName, applicationRef, host, routePathMetadata);\n      });\n    });\n  }\n\n  registerNotFoundHandler() {\n    const applicationRef = this.container.getHttpAdapterRef();\n\n    const callback = (req, res) => {\n      const method = applicationRef.getRequestMethod(req);\n      const url = applicationRef.getRequestUrl(req);\n      throw new common_1.NotFoundException(`Cannot ${method} ${url}`);\n    };\n\n    const handler = this.routerExceptionsFilter.create({}, callback, undefined);\n    const proxy = this.routerProxy.createProxy(callback, handler);\n    applicationRef.setNotFoundHandler && applicationRef.setNotFoundHandler(proxy, this.applicationConfig.getGlobalPrefix());\n  }\n\n  registerExceptionHandler() {\n    const callback = (err, req, res, next) => {\n      throw this.mapExternalException(err);\n    };\n\n    const handler = this.routerExceptionsFilter.create({}, callback, undefined);\n    const proxy = this.routerProxy.createExceptionLayerProxy(callback, handler);\n    const applicationRef = this.container.getHttpAdapterRef();\n    applicationRef.setErrorHandler && applicationRef.setErrorHandler(proxy, this.applicationConfig.getGlobalPrefix());\n  }\n\n  mapExternalException(err) {\n    switch (true) {\n      // SyntaxError is thrown by Express body-parser when given invalid JSON (#422, #430)\n      // URIError is thrown by Express when given a path parameter with an invalid percentage\n      // encoding, e.g. '%FF' (#8915)\n      case err instanceof SyntaxError || err instanceof URIError:\n        return new common_1.BadRequestException(err.message);\n\n      default:\n        return err;\n    }\n  }\n\n  getModulePathMetadata(metatype) {\n    const modulesContainer = this.container.getModules();\n    const modulePath = Reflect.getMetadata(constants_1.MODULE_PATH + modulesContainer.applicationId, metatype);\n    return modulePath !== null && modulePath !== void 0 ? modulePath : Reflect.getMetadata(constants_1.MODULE_PATH, metatype);\n  }\n\n  getHostMetadata(metatype) {\n    return Reflect.getMetadata(constants_1.HOST_METADATA, metatype);\n  }\n\n  getVersionMetadata(metatype) {\n    var _a;\n\n    const versioningConfig = this.applicationConfig.getVersioning();\n\n    if (versioningConfig) {\n      return (_a = Reflect.getMetadata(constants_1.VERSION_METADATA, metatype)) !== null && _a !== void 0 ? _a : versioningConfig.defaultVersion;\n    }\n  }\n\n}\n\nexports.RoutesResolver = RoutesResolver;","map":null,"metadata":{},"sourceType":"script"}