{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExpressAdapter = void 0;\n\nconst common_1 = require(\"@nestjs/common\");\n\nconst interfaces_1 = require(\"@nestjs/common/interfaces\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst http_adapter_1 = require(\"@nestjs/core/adapters/http-adapter\");\n\nconst router_method_factory_1 = require(\"@nestjs/core/helpers/router-method-factory\");\n\nconst body_parser_1 = require(\"body-parser\");\n\nconst cors = require(\"cors\");\n\nconst express = require(\"express\");\n\nconst http = require(\"http\");\n\nconst https = require(\"https\");\n\nclass ExpressAdapter extends http_adapter_1.AbstractHttpAdapter {\n  constructor(instance) {\n    super(instance || express());\n    this.routerMethodFactory = new router_method_factory_1.RouterMethodFactory();\n  }\n\n  reply(response, body, statusCode) {\n    if (statusCode) {\n      response.status(statusCode);\n    }\n\n    if ((0, shared_utils_1.isNil)(body)) {\n      return response.send();\n    }\n\n    if (body instanceof common_1.StreamableFile) {\n      const streamHeaders = body.getHeaders();\n\n      if (response.getHeader('Content-Type') === undefined && streamHeaders.type !== undefined) {\n        response.setHeader('Content-Type', streamHeaders.type);\n      }\n\n      if (response.getHeader('Content-Disposition') === undefined && streamHeaders.disposition !== undefined) {\n        response.setHeader('Content-Disposition', streamHeaders.disposition);\n      }\n\n      if (response.getHeader('Content-Length') === undefined && streamHeaders.length !== undefined) {\n        response.setHeader('Content-Length', streamHeaders.length);\n      }\n\n      return body.getStream().pipe(response);\n    }\n\n    return (0, shared_utils_1.isObject)(body) ? response.json(body) : response.send(String(body));\n  }\n\n  status(response, statusCode) {\n    return response.status(statusCode);\n  }\n\n  render(response, view, options) {\n    return response.render(view, options);\n  }\n\n  redirect(response, statusCode, url) {\n    return response.redirect(statusCode, url);\n  }\n\n  setErrorHandler(handler, prefix) {\n    return this.use(handler);\n  }\n\n  setNotFoundHandler(handler, prefix) {\n    return this.use(handler);\n  }\n\n  setHeader(response, name, value) {\n    return response.set(name, value);\n  }\n\n  listen(port, ...args) {\n    return this.httpServer.listen(port, ...args);\n  }\n\n  close() {\n    if (!this.httpServer) {\n      return undefined;\n    }\n\n    return new Promise(resolve => this.httpServer.close(resolve));\n  }\n\n  set(...args) {\n    return this.instance.set(...args);\n  }\n\n  enable(...args) {\n    return this.instance.enable(...args);\n  }\n\n  disable(...args) {\n    return this.instance.disable(...args);\n  }\n\n  engine(...args) {\n    return this.instance.engine(...args);\n  }\n\n  useStaticAssets(path, options) {\n    if (options && options.prefix) {\n      return this.use(options.prefix, express.static(path, options));\n    }\n\n    return this.use(express.static(path, options));\n  }\n\n  setBaseViewsDir(path) {\n    return this.set('views', path);\n  }\n\n  setViewEngine(engine) {\n    return this.set('view engine', engine);\n  }\n\n  getRequestHostname(request) {\n    return request.hostname;\n  }\n\n  getRequestMethod(request) {\n    return request.method;\n  }\n\n  getRequestUrl(request) {\n    return request.originalUrl;\n  }\n\n  enableCors(options) {\n    return this.use(cors(options));\n  }\n\n  createMiddlewareFactory(requestMethod) {\n    return this.routerMethodFactory.get(this.instance, requestMethod).bind(this.instance);\n  }\n\n  initHttpServer(options) {\n    const isHttpsEnabled = options && options.httpsOptions;\n\n    if (isHttpsEnabled) {\n      this.httpServer = https.createServer(options.httpsOptions, this.getInstance());\n      return;\n    }\n\n    this.httpServer = http.createServer(this.getInstance());\n  }\n\n  registerParserMiddleware(prefix, rawBody) {\n    let bodyParserJsonOptions;\n\n    if (rawBody === true) {\n      bodyParserJsonOptions = {\n        verify: (req, _res, buffer) => {\n          if (Buffer.isBuffer(buffer)) {\n            req.rawBody = buffer;\n          }\n\n          return true;\n        }\n      };\n    }\n\n    const parserMiddleware = {\n      jsonParser: (0, body_parser_1.json)(bodyParserJsonOptions),\n      urlencodedParser: (0, body_parser_1.urlencoded)({\n        extended: true\n      })\n    };\n    Object.keys(parserMiddleware).filter(parser => !this.isMiddlewareApplied(parser)).forEach(parserKey => this.use(parserMiddleware[parserKey]));\n  }\n\n  setLocal(key, value) {\n    this.instance.locals[key] = value;\n    return this;\n  }\n\n  getType() {\n    return 'express';\n  }\n\n  applyVersionFilter(handler, version, versioningOptions) {\n    const callNextHandler = (req, res, next) => {\n      if (!next) {\n        throw new common_1.InternalServerErrorException('HTTP adapter does not support filtering on version');\n      }\n\n      return next();\n    };\n\n    if (version === interfaces_1.VERSION_NEUTRAL || // URL Versioning is done via the path, so the filter continues forward\n    versioningOptions.type === common_1.VersioningType.URI) {\n      const handlerForNoVersioning = (req, res, next) => handler(req, res, next);\n\n      return handlerForNoVersioning;\n    } // Custom Extractor Versioning Handler\n\n\n    if (versioningOptions.type === common_1.VersioningType.CUSTOM) {\n      const handlerForCustomVersioning = (req, res, next) => {\n        const extractedVersion = versioningOptions.extractor(req);\n\n        if (Array.isArray(version)) {\n          if (Array.isArray(extractedVersion) && version.filter(v => extractedVersion.includes(v)).length) {\n            return handler(req, res, next);\n          }\n\n          if ((0, shared_utils_1.isString)(extractedVersion) && version.includes(extractedVersion)) {\n            return handler(req, res, next);\n          }\n        } else if ((0, shared_utils_1.isString)(version)) {\n          // Known bug here - if there are multiple versions supported across separate\n          // handlers/controllers, we can't select the highest matching handler.\n          // Since this code is evaluated per-handler, then we can't see if the highest\n          // specified version exists in a different handler.\n          if (Array.isArray(extractedVersion) && extractedVersion.includes(version)) {\n            return handler(req, res, next);\n          }\n\n          if ((0, shared_utils_1.isString)(extractedVersion) && version === extractedVersion) {\n            return handler(req, res, next);\n          }\n        }\n\n        return callNextHandler(req, res, next);\n      };\n\n      return handlerForCustomVersioning;\n    } // Media Type (Accept Header) Versioning Handler\n\n\n    if (versioningOptions.type === common_1.VersioningType.MEDIA_TYPE) {\n      const handlerForMediaTypeVersioning = (req, res, next) => {\n        var _a, _b;\n\n        const MEDIA_TYPE_HEADER = 'Accept';\n        const acceptHeaderValue = ((_a = req.headers) === null || _a === void 0 ? void 0 : _a[MEDIA_TYPE_HEADER]) || ((_b = req.headers) === null || _b === void 0 ? void 0 : _b[MEDIA_TYPE_HEADER.toLowerCase()]);\n        const acceptHeaderVersionParameter = acceptHeaderValue ? acceptHeaderValue.split(';')[1] : undefined; // No version was supplied\n\n        if ((0, shared_utils_1.isUndefined)(acceptHeaderVersionParameter)) {\n          if (Array.isArray(version)) {\n            if (version.includes(interfaces_1.VERSION_NEUTRAL)) {\n              return handler(req, res, next);\n            }\n          }\n        } else {\n          const headerVersion = acceptHeaderVersionParameter.split(versioningOptions.key)[1];\n\n          if (Array.isArray(version)) {\n            if (version.includes(headerVersion)) {\n              return handler(req, res, next);\n            }\n          } else if ((0, shared_utils_1.isString)(version)) {\n            if (version === headerVersion) {\n              return handler(req, res, next);\n            }\n          }\n        }\n\n        return callNextHandler(req, res, next);\n      };\n\n      return handlerForMediaTypeVersioning;\n    } // Header Versioning Handler\n\n\n    if (versioningOptions.type === common_1.VersioningType.HEADER) {\n      const handlerForHeaderVersioning = (req, res, next) => {\n        var _a, _b;\n\n        const customHeaderVersionParameter = ((_a = req.headers) === null || _a === void 0 ? void 0 : _a[versioningOptions.header]) || ((_b = req.headers) === null || _b === void 0 ? void 0 : _b[versioningOptions.header.toLowerCase()]); // No version was supplied\n\n        if ((0, shared_utils_1.isUndefined)(customHeaderVersionParameter)) {\n          if (Array.isArray(version)) {\n            if (version.includes(interfaces_1.VERSION_NEUTRAL)) {\n              return handler(req, res, next);\n            }\n          }\n        } else {\n          if (Array.isArray(version)) {\n            if (version.includes(customHeaderVersionParameter)) {\n              return handler(req, res, next);\n            }\n          } else if ((0, shared_utils_1.isString)(version)) {\n            if (version === customHeaderVersionParameter) {\n              return handler(req, res, next);\n            }\n          }\n        }\n\n        return callNextHandler(req, res, next);\n      };\n\n      return handlerForHeaderVersioning;\n    }\n  }\n\n  isMiddlewareApplied(name) {\n    const app = this.getInstance();\n    return !!app._router && !!app._router.stack && (0, shared_utils_1.isFunction)(app._router.stack.filter) && app._router.stack.some(layer => layer && layer.handle && layer.handle.name === name);\n  }\n\n}\n\nexports.ExpressAdapter = ExpressAdapter;","map":null,"metadata":{},"sourceType":"script"}