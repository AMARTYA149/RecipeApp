{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MICROSERVICES_PACKAGE_NOT_FOUND_EXCEPTION = exports.INVALID_EXCEPTION_FILTER = exports.UNHANDLED_RUNTIME_EXCEPTION = exports.UNKNOWN_REQUEST_MAPPING = exports.INVALID_MIDDLEWARE_CONFIGURATION = exports.INVALID_CLASS_SCOPE_MESSAGE = exports.INVALID_CLASS_MESSAGE = exports.UNKNOWN_EXPORT_MESSAGE = exports.UNDEFINED_MODULE_MESSAGE = exports.USING_INVALID_CLASS_AS_A_MODULE_MESSAGE = exports.INVALID_MODULE_MESSAGE = exports.UNDEFINED_FORWARDREF_MESSAGE = exports.INVALID_MIDDLEWARE_MESSAGE = exports.UNKNOWN_DEPENDENCIES_MESSAGE = void 0;\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n/**\n * Returns the name of an instance or `undefined`\n * @param instance The instance which should get the name from\n */\n\n\nconst getInstanceName = instance => {\n  var _a, _b;\n\n  if (instance === null || instance === void 0 ? void 0 : instance.forwardRef) {\n    return (_a = instance.forwardRef()) === null || _a === void 0 ? void 0 : _a.name;\n  }\n\n  if (instance === null || instance === void 0 ? void 0 : instance.module) {\n    return (_b = instance.module) === null || _b === void 0 ? void 0 : _b.name;\n  }\n\n  return instance === null || instance === void 0 ? void 0 : instance.name;\n};\n/**\n * Returns the name of the dependency\n * Tries to get the class name, otherwise the string value\n * (= injection token). As fallback it returns '+'\n * @param dependency The dependency whichs name should get displayed\n */\n\n\nconst getDependencyName = dependency => // use class name\ngetInstanceName(dependency) || // use injection token (symbol)\n(0, shared_utils_1.isSymbol)(dependency) && dependency.toString() || // use string directly\ndependency || // otherwise\n'+';\n/**\n * Returns the name of the module\n * Tries to get the class name. As fallback it returns 'current'.\n * @param module The module which should get displayed\n */\n\n\nconst getModuleName = module => module && getInstanceName(module.metatype) || 'current';\n\nconst stringifyScope = scope => (scope || []).map(getInstanceName).join(' -> ');\n\nconst UNKNOWN_DEPENDENCIES_MESSAGE = (type, unknownDependencyContext, module) => {\n  const {\n    index,\n    name = 'dependency',\n    dependencies,\n    key\n  } = unknownDependencyContext;\n  const moduleName = getModuleName(module) || 'Module';\n  const dependencyName = getDependencyName(name);\n  let message = `Nest can't resolve dependencies of the ${type.toString()}`;\n  const potentialSolutions = `\\n\nPotential solutions:\n- If ${dependencyName} is a provider, is it part of the current ${moduleName}?\n- If ${dependencyName} is exported from a separate @Module, is that module imported within ${moduleName}?\n  @Module({\n    imports: [ /* the Module containing ${dependencyName} */ ]\n  })\n`;\n\n  if ((0, shared_utils_1.isNil)(index)) {\n    message += `. Please make sure that the \"${key.toString()}\" property is available in the current context.${potentialSolutions}`;\n    return message;\n  }\n\n  const dependenciesName = (dependencies || []).map(getDependencyName);\n  dependenciesName[index] = '?';\n  message += ` (`;\n  message += dependenciesName.join(', ');\n  message += `). Please make sure that the argument ${dependencyName} at index [${index}] is available in the ${getModuleName(module)} context.`;\n  message += potentialSolutions;\n  return message;\n};\n\nexports.UNKNOWN_DEPENDENCIES_MESSAGE = UNKNOWN_DEPENDENCIES_MESSAGE;\n\nconst INVALID_MIDDLEWARE_MESSAGE = (text, name) => `The middleware doesn't provide the 'use' method (${name})`;\n\nexports.INVALID_MIDDLEWARE_MESSAGE = INVALID_MIDDLEWARE_MESSAGE;\n\nconst UNDEFINED_FORWARDREF_MESSAGE = scope => `Nest cannot create the module instance. Often, this is because of a circular dependency between modules. Use forwardRef() to avoid it.\n\n(Read more: https://docs.nestjs.com/fundamentals/circular-dependency)\nScope [${stringifyScope(scope)}]\n`;\n\nexports.UNDEFINED_FORWARDREF_MESSAGE = UNDEFINED_FORWARDREF_MESSAGE;\n\nconst INVALID_MODULE_MESSAGE = (parentModule, index, scope) => {\n  const parentModuleName = (parentModule === null || parentModule === void 0 ? void 0 : parentModule.name) || 'module';\n  return `Nest cannot create the ${parentModuleName} instance.\nReceived an unexpected value at index [${index}] of the ${parentModuleName} \"imports\" array.\n\nScope [${stringifyScope(scope)}]`;\n};\n\nexports.INVALID_MODULE_MESSAGE = INVALID_MODULE_MESSAGE;\n\nconst USING_INVALID_CLASS_AS_A_MODULE_MESSAGE = (metatypeUsedAsAModule, scope) => {\n  const metatypeName = getInstanceName(metatypeUsedAsAModule) || 'found'; // TODO(v9): Edit the message below:\n\n  return `In the next major version, Nest will not allow classes annotated with @Injectable(), @Catch(), and @Controller() decorators to appear in the \"imports\" array of a module.\nPlease remove \"${metatypeName}\" (including forwarded occurrences, if any) from all of the \"imports\" arrays.\n\nScope [${stringifyScope(scope)}]\n`;\n};\n\nexports.USING_INVALID_CLASS_AS_A_MODULE_MESSAGE = USING_INVALID_CLASS_AS_A_MODULE_MESSAGE;\n\nconst UNDEFINED_MODULE_MESSAGE = (parentModule, index, scope) => {\n  const parentModuleName = (parentModule === null || parentModule === void 0 ? void 0 : parentModule.name) || 'module';\n  return `Nest cannot create the ${parentModuleName} instance.\nThe module at index [${index}] of the ${parentModuleName} \"imports\" array is undefined.\n\nPotential causes:\n- A circular dependency between modules. Use forwardRef() to avoid it. Read more: https://docs.nestjs.com/fundamentals/circular-dependency\n- The module at index [${index}] is of type \"undefined\". Check your import statements and the type of the module.\n\nScope [${stringifyScope(scope)}]`;\n};\n\nexports.UNDEFINED_MODULE_MESSAGE = UNDEFINED_MODULE_MESSAGE;\n\nconst UNKNOWN_EXPORT_MESSAGE = (token = 'item', module) => {\n  token = (0, shared_utils_1.isSymbol)(token) ? token.toString() : token;\n  return `Nest cannot export a provider/module that is not a part of the currently processed module (${module}). Please verify whether the exported ${token} is available in this particular context.\n\nPossible Solutions:\n- Is ${token} part of the relevant providers/imports within ${module}?\n`;\n};\n\nexports.UNKNOWN_EXPORT_MESSAGE = UNKNOWN_EXPORT_MESSAGE;\n\nconst INVALID_CLASS_MESSAGE = (text, value) => `ModuleRef cannot instantiate class (${value} is not constructable).`;\n\nexports.INVALID_CLASS_MESSAGE = INVALID_CLASS_MESSAGE;\n\nconst INVALID_CLASS_SCOPE_MESSAGE = (text, name) => `${name || 'This class'} is marked as a scoped provider. Request and transient-scoped providers can't be used in combination with \"get()\" method. Please, use \"resolve()\" instead.`;\n\nexports.INVALID_CLASS_SCOPE_MESSAGE = INVALID_CLASS_SCOPE_MESSAGE;\nexports.INVALID_MIDDLEWARE_CONFIGURATION = `An invalid middleware configuration has been passed inside the module 'configure()' method.`;\nexports.UNKNOWN_REQUEST_MAPPING = `An invalid controller has been detected. Perhaps, one of your controllers is missing @Controller() decorator.`;\nexports.UNHANDLED_RUNTIME_EXCEPTION = `Unhandled Runtime Exception.`;\nexports.INVALID_EXCEPTION_FILTER = `Invalid exception filters (@UseFilters()).`;\nexports.MICROSERVICES_PACKAGE_NOT_FOUND_EXCEPTION = `Unable to load @nestjs/microservices package. (Please make sure that it's already installed.)`;","map":null,"metadata":{},"sourceType":"script"}