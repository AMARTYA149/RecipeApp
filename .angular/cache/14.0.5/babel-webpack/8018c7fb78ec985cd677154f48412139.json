{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/amartya_aishwarya/Desktop/nextjs-angular/RecipeApp/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RouterResponseController = void 0;\n\nconst common_1 = require(\"@nestjs/common\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst sse_stream_1 = require(\"./sse-stream\");\n\nclass RouterResponseController {\n  constructor(applicationRef) {\n    this.applicationRef = applicationRef;\n    this.logger = new common_1.Logger(RouterResponseController.name);\n  }\n\n  apply(result, response, httpStatusCode) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.applicationRef.reply(response, result, httpStatusCode);\n    })();\n  }\n\n  redirect(resultOrDeferred, response, redirectResponse) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const result = yield _this2.transformToResult(resultOrDeferred);\n      const statusCode = result && result.statusCode ? result.statusCode : redirectResponse.statusCode ? redirectResponse.statusCode : common_1.HttpStatus.FOUND;\n      const url = result && result.url ? result.url : redirectResponse.url;\n\n      _this2.applicationRef.redirect(response, statusCode, url);\n    })();\n  }\n\n  render(resultOrDeferred, response, template) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const result = yield _this3.transformToResult(resultOrDeferred);\n      return _this3.applicationRef.render(response, template, result);\n    })();\n  }\n\n  transformToResult(resultOrDeferred) {\n    return _asyncToGenerator(function* () {\n      if (resultOrDeferred && (0, shared_utils_1.isFunction)(resultOrDeferred.subscribe)) {\n        return (0, rxjs_1.lastValueFrom)(resultOrDeferred);\n      }\n\n      return resultOrDeferred;\n    })();\n  }\n\n  getStatusByMethod(requestMethod) {\n    switch (requestMethod) {\n      case common_1.RequestMethod.POST:\n        return common_1.HttpStatus.CREATED;\n\n      default:\n        return common_1.HttpStatus.OK;\n    }\n  }\n\n  setHeaders(response, headers) {\n    headers.forEach(({\n      name,\n      value\n    }) => this.applicationRef.setHeader(response, name, value));\n  }\n\n  setStatus(response, statusCode) {\n    this.applicationRef.status(response, statusCode);\n  }\n\n  sse(result, response, request, options) {\n    // It's possible that we sent headers already so don't use a stream\n    if (response.writableEnded) {\n      return;\n    }\n\n    this.assertObservable(result);\n    const stream = new sse_stream_1.SseStream(request);\n    stream.pipe(response, options);\n    const subscription = result.pipe((0, operators_1.map)(message => {\n      if ((0, shared_utils_1.isObject)(message)) {\n        return message;\n      }\n\n      return {\n        data: message\n      };\n    }), (0, operators_1.debounce)(message => new Promise(resolve => stream.writeMessage(message, () => resolve()))), (0, operators_1.catchError)(err => {\n      const data = err instanceof Error ? err.message : err;\n      stream.writeMessage({\n        type: 'error',\n        data\n      }, writeError => {\n        if (writeError) {\n          this.logger.error(writeError);\n        }\n      });\n      return rxjs_1.EMPTY;\n    })).subscribe({\n      complete: () => {\n        response.end();\n      }\n    });\n    request.on('close', () => {\n      subscription.unsubscribe();\n    });\n  }\n\n  assertObservable(result) {\n    if (!(0, shared_utils_1.isFunction)(result.subscribe)) {\n      throw new ReferenceError('You must return an Observable stream to use Server-Sent Events (SSE).');\n    }\n  }\n\n}\n\nexports.RouterResponseController = RouterResponseController;","map":null,"metadata":{},"sourceType":"script"}