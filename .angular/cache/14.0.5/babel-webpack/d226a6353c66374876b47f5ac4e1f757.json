{"ast":null,"code":"\"use strict\";\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InstanceWrapper = exports.INSTANCE_ID_SYMBOL = exports.INSTANCE_METADATA_SYMBOL = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst common_1 = require(\"@nestjs/common\");\n\nconst random_string_generator_util_1 = require(\"@nestjs/common/utils/random-string-generator.util\");\n\nconst shared_utils_1 = require(\"@nestjs/common/utils/shared.utils\");\n\nconst iterare_1 = require(\"iterare\");\n\nconst constants_1 = require(\"./constants\");\n\nexports.INSTANCE_METADATA_SYMBOL = Symbol.for('instance_metadata:cache');\nexports.INSTANCE_ID_SYMBOL = Symbol.for('instance_metadata:id');\n\nclass InstanceWrapper {\n  constructor(metadata = {}) {\n    this.isAlias = false;\n    this.scope = common_1.Scope.DEFAULT;\n    this.values = new WeakMap();\n    this[_a] = {};\n    this[exports.INSTANCE_ID_SYMBOL] = (0, random_string_generator_util_1.randomStringGenerator)();\n    this.initialize(metadata);\n  }\n\n  get id() {\n    return this[exports.INSTANCE_ID_SYMBOL];\n  }\n\n  set instance(value) {\n    this.values.set(constants_1.STATIC_CONTEXT, {\n      instance: value\n    });\n  }\n\n  get instance() {\n    const instancePerContext = this.getInstanceByContextId(constants_1.STATIC_CONTEXT);\n    return instancePerContext.instance;\n  }\n\n  get isNotMetatype() {\n    const isFactory = this.metatype && !(0, shared_utils_1.isNil)(this.inject);\n    return !this.metatype || isFactory;\n  }\n\n  get isTransient() {\n    return this.scope === common_1.Scope.TRANSIENT;\n  }\n\n  getInstanceByContextId(contextId, inquirerId) {\n    if (this.scope === common_1.Scope.TRANSIENT && inquirerId) {\n      return this.getInstanceByInquirerId(contextId, inquirerId);\n    }\n\n    const instancePerContext = this.values.get(contextId);\n    return instancePerContext ? instancePerContext : this.cloneStaticInstance(contextId);\n  }\n\n  getInstanceByInquirerId(contextId, inquirerId) {\n    let collectionPerContext = this.transientMap.get(inquirerId);\n\n    if (!collectionPerContext) {\n      collectionPerContext = new WeakMap();\n      this.transientMap.set(inquirerId, collectionPerContext);\n    }\n\n    const instancePerContext = collectionPerContext.get(contextId);\n    return instancePerContext ? instancePerContext : this.cloneTransientInstance(contextId, inquirerId);\n  }\n\n  setInstanceByContextId(contextId, value, inquirerId) {\n    if (this.scope === common_1.Scope.TRANSIENT && inquirerId) {\n      return this.setInstanceByInquirerId(contextId, inquirerId, value);\n    }\n\n    this.values.set(contextId, value);\n  }\n\n  setInstanceByInquirerId(contextId, inquirerId, value) {\n    let collection = this.transientMap.get(inquirerId);\n\n    if (!collection) {\n      collection = new WeakMap();\n      this.transientMap.set(inquirerId, collection);\n    }\n\n    collection.set(contextId, value);\n  }\n\n  addCtorMetadata(index, wrapper) {\n    if (!this[exports.INSTANCE_METADATA_SYMBOL].dependencies) {\n      this[exports.INSTANCE_METADATA_SYMBOL].dependencies = [];\n    }\n\n    this[exports.INSTANCE_METADATA_SYMBOL].dependencies[index] = wrapper;\n  }\n\n  getCtorMetadata() {\n    return this[exports.INSTANCE_METADATA_SYMBOL].dependencies;\n  }\n\n  addPropertiesMetadata(key, wrapper) {\n    if (!this[exports.INSTANCE_METADATA_SYMBOL].properties) {\n      this[exports.INSTANCE_METADATA_SYMBOL].properties = [];\n    }\n\n    this[exports.INSTANCE_METADATA_SYMBOL].properties.push({\n      key,\n      wrapper\n    });\n  }\n\n  getPropertiesMetadata() {\n    return this[exports.INSTANCE_METADATA_SYMBOL].properties;\n  }\n\n  addEnhancerMetadata(wrapper) {\n    if (!this[exports.INSTANCE_METADATA_SYMBOL].enhancers) {\n      this[exports.INSTANCE_METADATA_SYMBOL].enhancers = [];\n    }\n\n    this[exports.INSTANCE_METADATA_SYMBOL].enhancers.push(wrapper);\n  }\n\n  getEnhancersMetadata() {\n    return this[exports.INSTANCE_METADATA_SYMBOL].enhancers;\n  }\n\n  isDependencyTreeStatic(lookupRegistry = []) {\n    if (!(0, shared_utils_1.isUndefined)(this.isTreeStatic)) {\n      return this.isTreeStatic;\n    }\n\n    if (this.scope === common_1.Scope.REQUEST) {\n      this.isTreeStatic = false;\n      return this.isTreeStatic;\n    }\n\n    if (lookupRegistry.includes(this[exports.INSTANCE_ID_SYMBOL])) {\n      return true;\n    }\n\n    lookupRegistry = lookupRegistry.concat(this[exports.INSTANCE_ID_SYMBOL]);\n    const {\n      dependencies,\n      properties,\n      enhancers\n    } = this[exports.INSTANCE_METADATA_SYMBOL];\n    let isStatic = dependencies && this.isWrapperListStatic(dependencies, lookupRegistry) || !dependencies;\n\n    if (!isStatic || !(properties || enhancers)) {\n      this.isTreeStatic = isStatic;\n      return this.isTreeStatic;\n    }\n\n    const propertiesHosts = (properties || []).map(item => item.wrapper);\n    isStatic = isStatic && this.isWrapperListStatic(propertiesHosts, lookupRegistry);\n\n    if (!isStatic || !enhancers) {\n      this.isTreeStatic = isStatic;\n      return this.isTreeStatic;\n    }\n\n    this.isTreeStatic = this.isWrapperListStatic(enhancers, lookupRegistry);\n    return this.isTreeStatic;\n  }\n\n  cloneStaticInstance(contextId) {\n    const staticInstance = this.getInstanceByContextId(constants_1.STATIC_CONTEXT);\n\n    if (this.isDependencyTreeStatic()) {\n      return staticInstance;\n    }\n\n    const instancePerContext = Object.assign(Object.assign({}, staticInstance), {\n      instance: undefined,\n      isResolved: false,\n      isPending: false\n    });\n\n    if (this.isNewable()) {\n      instancePerContext.instance = Object.create(this.metatype.prototype);\n    }\n\n    this.setInstanceByContextId(contextId, instancePerContext);\n    return instancePerContext;\n  }\n\n  cloneTransientInstance(contextId, inquirerId) {\n    const staticInstance = this.getInstanceByContextId(constants_1.STATIC_CONTEXT);\n    const instancePerContext = Object.assign(Object.assign({}, staticInstance), {\n      instance: undefined,\n      isResolved: false,\n      isPending: false\n    });\n\n    if (this.isNewable()) {\n      instancePerContext.instance = Object.create(this.metatype.prototype);\n    }\n\n    this.setInstanceByInquirerId(contextId, inquirerId, instancePerContext);\n    return instancePerContext;\n  }\n\n  createPrototype(contextId) {\n    const host = this.getInstanceByContextId(contextId);\n\n    if (!this.isNewable() || host.isResolved) {\n      return;\n    }\n\n    return Object.create(this.metatype.prototype);\n  }\n\n  isInRequestScope(contextId, inquirer) {\n    const isDependencyTreeStatic = this.isDependencyTreeStatic();\n    return !isDependencyTreeStatic && contextId !== constants_1.STATIC_CONTEXT && (!this.isTransient || this.isTransient && !!inquirer);\n  }\n\n  isLazyTransient(contextId, inquirer) {\n    const isInquirerRequestScoped = inquirer && !inquirer.isDependencyTreeStatic();\n    return this.isDependencyTreeStatic() && contextId !== constants_1.STATIC_CONTEXT && this.isTransient && isInquirerRequestScoped;\n  }\n\n  isExplicitlyRequested(contextId, inquirer) {\n    const isSelfRequested = inquirer === this;\n    return this.isDependencyTreeStatic() && contextId !== constants_1.STATIC_CONTEXT && (isSelfRequested || inquirer && inquirer.scope === common_1.Scope.TRANSIENT);\n  }\n\n  isStatic(contextId, inquirer) {\n    const isInquirerRequestScoped = inquirer && !inquirer.isDependencyTreeStatic();\n    const isStaticTransient = this.isTransient && !isInquirerRequestScoped;\n    return this.isDependencyTreeStatic() && contextId === constants_1.STATIC_CONTEXT && (!this.isTransient || isStaticTransient && !!inquirer && !inquirer.isTransient);\n  }\n\n  getStaticTransientInstances() {\n    if (!this.transientMap) {\n      return [];\n    }\n\n    const instances = [...this.transientMap.values()];\n    return (0, iterare_1.iterate)(instances).map(item => item.get(constants_1.STATIC_CONTEXT)).filter(item => !!item).toArray();\n  }\n\n  mergeWith(provider) {\n    if (!(0, shared_utils_1.isUndefined)(provider.useValue)) {\n      this.metatype = null;\n      this.inject = null;\n      this.scope = common_1.Scope.DEFAULT;\n      this.setInstanceByContextId(constants_1.STATIC_CONTEXT, {\n        instance: provider.useValue,\n        isResolved: true,\n        isPending: false\n      });\n    } else if (provider.useClass) {\n      this.inject = null;\n      this.metatype = provider.useClass;\n    } else if (provider.useFactory) {\n      this.metatype = provider.useFactory;\n      this.inject = provider.inject || [];\n    }\n  }\n\n  isNewable() {\n    return (0, shared_utils_1.isNil)(this.inject) && this.metatype && this.metatype.prototype;\n  }\n\n  isWrapperListStatic(tree, lookupRegistry) {\n    return tree.every(item => item.isDependencyTreeStatic(lookupRegistry));\n  }\n\n  initialize(metadata) {\n    const {\n      instance,\n      isResolved\n    } = metadata,\n          wrapperPartial = tslib_1.__rest(metadata, [\"instance\", \"isResolved\"]);\n\n    Object.assign(this, wrapperPartial);\n    this.setInstanceByContextId(constants_1.STATIC_CONTEXT, {\n      instance,\n      isResolved\n    });\n    this.scope === common_1.Scope.TRANSIENT && (this.transientMap = new Map());\n  }\n\n}\n\nexports.InstanceWrapper = InstanceWrapper;\n_a = exports.INSTANCE_METADATA_SYMBOL;","map":null,"metadata":{},"sourceType":"script"}