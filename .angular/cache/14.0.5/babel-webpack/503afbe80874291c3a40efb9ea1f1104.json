{"ast":null,"code":"\"use strict\";\n\nvar Logger_1;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Logger = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst injectable_decorator_1 = require(\"../decorators/core/injectable.decorator\");\n\nconst optional_decorator_1 = require(\"../decorators/core/optional.decorator\");\n\nconst shared_utils_1 = require(\"../utils/shared.utils\");\n\nconst console_logger_service_1 = require(\"./console-logger.service\");\n\nconst utils_1 = require(\"./utils\");\n\nconst DEFAULT_LOGGER = new console_logger_service_1.ConsoleLogger();\nlet Logger = Logger_1 = class Logger {\n  constructor(context, options = {}) {\n    this.context = context;\n    this.options = options;\n  }\n\n  get localInstance() {\n    if (Logger_1.staticInstanceRef === DEFAULT_LOGGER) {\n      return this.registerLocalInstanceRef();\n    } else if (Logger_1.staticInstanceRef instanceof Logger_1) {\n      const prototype = Object.getPrototypeOf(Logger_1.staticInstanceRef);\n\n      if (prototype.constructor === Logger_1) {\n        return this.registerLocalInstanceRef();\n      }\n    }\n\n    return Logger_1.staticInstanceRef;\n  }\n\n  error(message, ...optionalParams) {\n    var _a;\n\n    optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;\n    (_a = this.localInstance) === null || _a === void 0 ? void 0 : _a.error(message, ...optionalParams);\n  }\n\n  log(message, ...optionalParams) {\n    var _a;\n\n    optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;\n    (_a = this.localInstance) === null || _a === void 0 ? void 0 : _a.log(message, ...optionalParams);\n  }\n\n  warn(message, ...optionalParams) {\n    var _a;\n\n    optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;\n    (_a = this.localInstance) === null || _a === void 0 ? void 0 : _a.warn(message, ...optionalParams);\n  }\n\n  debug(message, ...optionalParams) {\n    var _a, _b;\n\n    optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;\n    (_b = (_a = this.localInstance) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, message, ...optionalParams);\n  }\n\n  verbose(message, ...optionalParams) {\n    var _a, _b;\n\n    optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;\n    (_b = (_a = this.localInstance) === null || _a === void 0 ? void 0 : _a.verbose) === null || _b === void 0 ? void 0 : _b.call(_a, message, ...optionalParams);\n  }\n\n  static error(message, ...optionalParams) {\n    var _a;\n\n    (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.error(message, ...optionalParams);\n  }\n\n  static log(message, ...optionalParams) {\n    var _a;\n\n    (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.log(message, ...optionalParams);\n  }\n\n  static warn(message, ...optionalParams) {\n    var _a;\n\n    (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.warn(message, ...optionalParams);\n  }\n\n  static debug(message, ...optionalParams) {\n    var _a, _b;\n\n    (_b = (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, message, ...optionalParams);\n  }\n\n  static verbose(message, ...optionalParams) {\n    var _a, _b;\n\n    (_b = (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.verbose) === null || _b === void 0 ? void 0 : _b.call(_a, message, ...optionalParams);\n  }\n  /**\n   * Print buffered logs and detach buffer.\n   */\n\n\n  static flush() {\n    this.isBufferAttached = false;\n    this.logBuffer.forEach(item => item.methodRef(...item.arguments));\n    this.logBuffer = [];\n  }\n  /**\n   * Attach buffer.\n   * Turns on initialisation logs buffering.\n   */\n\n\n  static attachBuffer() {\n    this.isBufferAttached = true;\n  }\n  /**\n   * Detach buffer.\n   * Turns off initialisation logs buffering.\n   */\n\n\n  static detachBuffer() {\n    this.isBufferAttached = false;\n  }\n\n  static getTimestamp() {\n    const localeStringOptions = {\n      year: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric',\n      day: '2-digit',\n      month: '2-digit'\n    };\n    return new Date(Date.now()).toLocaleString(undefined, localeStringOptions);\n  }\n\n  static overrideLogger(logger) {\n    var _a;\n\n    if (Array.isArray(logger)) {\n      Logger_1.logLevels = logger;\n      return (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.setLogLevels(logger);\n    }\n\n    if ((0, shared_utils_1.isObject)(logger)) {\n      if (logger instanceof Logger_1 && logger.constructor !== Logger_1) {\n        const errorMessage = `Using the \"extends Logger\" instruction is not allowed in Nest v8. Please, use \"extends ConsoleLogger\" instead.`;\n        this.staticInstanceRef.error(errorMessage);\n        throw new Error(errorMessage);\n      }\n\n      this.staticInstanceRef = logger;\n    } else {\n      this.staticInstanceRef = undefined;\n    }\n  }\n\n  static isLevelEnabled(level) {\n    const logLevels = Logger_1.logLevels;\n    return (0, utils_1.isLogLevelEnabled)(level, logLevels);\n  }\n\n  registerLocalInstanceRef() {\n    var _a;\n\n    if (this.localInstanceRef) {\n      return this.localInstanceRef;\n    }\n\n    this.localInstanceRef = new console_logger_service_1.ConsoleLogger(this.context, {\n      timestamp: (_a = this.options) === null || _a === void 0 ? void 0 : _a.timestamp,\n      logLevels: Logger_1.logLevels\n    });\n    return this.localInstanceRef;\n  }\n\n};\nLogger.logBuffer = new Array();\nLogger.staticInstanceRef = DEFAULT_LOGGER;\n\nLogger.WrapBuffer = (target, propertyKey, descriptor) => {\n  const originalFn = descriptor.value;\n\n  descriptor.value = function (...args) {\n    if (Logger_1.isBufferAttached) {\n      Logger_1.logBuffer.push({\n        methodRef: originalFn.bind(this),\n        arguments: args\n      });\n      return;\n    }\n\n    return originalFn.call(this, ...args);\n  };\n};\n\ntslib_1.__decorate([Logger_1.WrapBuffer, tslib_1.__metadata(\"design:type\", Function), tslib_1.__metadata(\"design:paramtypes\", [Object, Object]), tslib_1.__metadata(\"design:returntype\", void 0)], Logger.prototype, \"error\", null);\n\ntslib_1.__decorate([Logger_1.WrapBuffer, tslib_1.__metadata(\"design:type\", Function), tslib_1.__metadata(\"design:paramtypes\", [Object, Object]), tslib_1.__metadata(\"design:returntype\", void 0)], Logger.prototype, \"log\", null);\n\ntslib_1.__decorate([Logger_1.WrapBuffer, tslib_1.__metadata(\"design:type\", Function), tslib_1.__metadata(\"design:paramtypes\", [Object, Object]), tslib_1.__metadata(\"design:returntype\", void 0)], Logger.prototype, \"warn\", null);\n\ntslib_1.__decorate([Logger_1.WrapBuffer, tslib_1.__metadata(\"design:type\", Function), tslib_1.__metadata(\"design:paramtypes\", [Object, Object]), tslib_1.__metadata(\"design:returntype\", void 0)], Logger.prototype, \"debug\", null);\n\ntslib_1.__decorate([Logger_1.WrapBuffer, tslib_1.__metadata(\"design:type\", Function), tslib_1.__metadata(\"design:paramtypes\", [Object, Object]), tslib_1.__metadata(\"design:returntype\", void 0)], Logger.prototype, \"verbose\", null);\n\ntslib_1.__decorate([Logger_1.WrapBuffer, tslib_1.__metadata(\"design:type\", Function), tslib_1.__metadata(\"design:paramtypes\", [Object, Object]), tslib_1.__metadata(\"design:returntype\", void 0)], Logger, \"error\", null);\n\ntslib_1.__decorate([Logger_1.WrapBuffer, tslib_1.__metadata(\"design:type\", Function), tslib_1.__metadata(\"design:paramtypes\", [Object, Object]), tslib_1.__metadata(\"design:returntype\", void 0)], Logger, \"log\", null);\n\ntslib_1.__decorate([Logger_1.WrapBuffer, tslib_1.__metadata(\"design:type\", Function), tslib_1.__metadata(\"design:paramtypes\", [Object, Object]), tslib_1.__metadata(\"design:returntype\", void 0)], Logger, \"warn\", null);\n\ntslib_1.__decorate([Logger_1.WrapBuffer, tslib_1.__metadata(\"design:type\", Function), tslib_1.__metadata(\"design:paramtypes\", [Object, Object]), tslib_1.__metadata(\"design:returntype\", void 0)], Logger, \"debug\", null);\n\ntslib_1.__decorate([Logger_1.WrapBuffer, tslib_1.__metadata(\"design:type\", Function), tslib_1.__metadata(\"design:paramtypes\", [Object, Object]), tslib_1.__metadata(\"design:returntype\", void 0)], Logger, \"verbose\", null);\n\nLogger = Logger_1 = tslib_1.__decorate([(0, injectable_decorator_1.Injectable)(), tslib_1.__param(0, (0, optional_decorator_1.Optional)()), tslib_1.__param(1, (0, optional_decorator_1.Optional)()), tslib_1.__metadata(\"design:paramtypes\", [String, Object])], Logger);\nexports.Logger = Logger;","map":null,"metadata":{},"sourceType":"script"}