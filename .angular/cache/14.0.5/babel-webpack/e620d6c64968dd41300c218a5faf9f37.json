{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Inject = void 0;\n\nconst constants_1 = require(\"../../constants\");\n\nconst shared_utils_1 = require(\"../../utils/shared.utils\");\n/**\n * Decorator that marks a constructor parameter as a target for\n * [Dependency Injection (DI)](https://docs.nestjs.com/providers#dependency-injection).\n *\n * Any injected provider must be visible within the module scope (loosely\n * speaking, the containing module) of the class it is being injected into. This\n * can be done by:\n *\n * - defining the provider in the same module scope\n * - exporting the provider from one module scope and importing that module into the\n *   module scope of the class being injected into\n * - exporting the provider from a module that is marked as global using the\n *   `@Global()` decorator\n *\n * #### Injection tokens\n * Can be *types* (class names), *strings* or *symbols*. This depends on how the\n * provider with which it is associated was defined. Providers defined with the\n * `@Injectable()` decorator use the class name. Custom Providers may use strings\n * or symbols as the injection token.\n *\n * @param token lookup key for the provider to be injected (assigned to the constructor\n * parameter).\n *\n * @see [Providers](https://docs.nestjs.com/providers)\n * @see [Custom Providers](https://docs.nestjs.com/fundamentals/custom-providers)\n * @see [Injection Scopes](https://docs.nestjs.com/fundamentals/injection-scopes)\n *\n * @publicApi\n */\n\n\nfunction Inject(token) {\n  return (target, key, index) => {\n    const type = token || Reflect.getMetadata('design:type', target, key);\n\n    if (!(0, shared_utils_1.isUndefined)(index)) {\n      let dependencies = Reflect.getMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, target) || [];\n      dependencies = [...dependencies, {\n        index,\n        param: type\n      }];\n      Reflect.defineMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, dependencies, target);\n      return;\n    }\n\n    let properties = Reflect.getMetadata(constants_1.PROPERTY_DEPS_METADATA, target.constructor) || [];\n    properties = [...properties, {\n      key,\n      type\n    }];\n    Reflect.defineMetadata(constants_1.PROPERTY_DEPS_METADATA, properties, target.constructor);\n  };\n}\n\nexports.Inject = Inject;","map":null,"metadata":{},"sourceType":"script"}