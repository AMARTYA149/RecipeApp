{"ast":null,"code":"import { ConstraintMetadata } from './metadata/ConstraintMetadata';\nimport { ValidationMetadata } from './metadata/ValidationMetadata';\nimport { ValidationTypes } from './validation/ValidationTypes';\nimport { getFromContainer } from './container';\nimport { MetadataStorage, getMetadataStorage } from './metadata/MetadataStorage';\n/**\n * Registers a custom validation decorator.\n */\n\nexport function registerDecorator(options) {\n  let constraintCls;\n\n  if (options.validator instanceof Function) {\n    constraintCls = options.validator;\n    const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n\n    if (constraintClasses.length > 1) {\n      throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target.name}:${options.propertyName}`;\n    }\n  } else {\n    const validator = options.validator;\n    constraintCls = class CustomConstraint {\n      validate(value, validationArguments) {\n        return validator.validate(value, validationArguments);\n      }\n\n      defaultMessage(validationArguments) {\n        if (validator.defaultMessage) {\n          return validator.defaultMessage(validationArguments);\n        }\n\n        return '';\n      }\n\n    };\n    getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n  }\n\n  const validationMetadataArgs = {\n    type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n    target: options.target,\n    propertyName: options.propertyName,\n    validationOptions: options.options,\n    constraintCls: constraintCls,\n    constraints: options.constraints\n  };\n  getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n} //# sourceMappingURL=register-decorator.js.map","map":null,"metadata":{},"sourceType":"module"}