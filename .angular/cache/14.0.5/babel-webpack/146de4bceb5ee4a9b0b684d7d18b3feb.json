{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst concat_1 = require(\"./concat\");\n\nconst filter_1 = require(\"./filter\");\n\nconst flatten_1 = require(\"./flatten\");\n\nconst map_1 = require(\"./map\");\n\nconst slice_1 = require(\"./slice\");\n\nconst utils_1 = require(\"./utils\");\n\nconst zip_1 = require(\"./zip\");\n\nclass IteratorWithOperators {\n  /**\n   * @param source Iterator to wrap\n   */\n  constructor(source) {\n    this.source = source;\n  }\n  /**\n   * Returns a `{ value, done }` object that adheres to the Iterator protocol\n   */\n\n\n  next() {\n    return this.source.next();\n  }\n  /**\n   * The presence of this method makes the Iterator itself Iterable.\n   * This makes it possible to pass it to `for of` and Iterable-accepting functions like `Array.from()`\n   */\n\n\n  [Symbol.iterator]() {\n    return this;\n  }\n  /**\n   * Returns a new Iterator by running each element thru iteratee\n   */\n\n\n  map(iteratee) {\n    return new IteratorWithOperators(new map_1.MapIterator(this.source, iteratee));\n  }\n\n  filter(predicate) {\n    return new IteratorWithOperators(new filter_1.FilterIterator(this.source, predicate));\n  }\n  /**\n   * Returns a new Iterator concatenating the Iterator with an additional Iterator or Iterable\n   */\n\n\n  concat(collection) {\n    return new IteratorWithOperators(new concat_1.ConcatIterator([this.source, utils_1.toIterator(collection)]));\n  }\n  /**\n   * Returns a new Iterator that emits slice of the source with n elements taken from the beginning\n   *\n   * @param limit The number of elements to take.\n   */\n\n\n  take(limit) {\n    return new IteratorWithOperators(new slice_1.SliceIterator(this.source, 0, limit + 1));\n  }\n  /**\n   * Returns a new Iterator that emits slice of the source with n elements dropped from the beginning\n   *\n   * @param n The number of elements to drop.\n   */\n\n\n  drop(n) {\n    return new IteratorWithOperators(new slice_1.SliceIterator(this.source, n, Infinity));\n  }\n  /**\n   * Returns a new Iterator that emits a slice of the source\n   *\n   * @param {number} start Zero-based positive start index, inclusive\n   * @param {number} end Zero-based positive end index, exclusive, defaults to end of iterator\n   */\n\n\n  slice(start, end = Infinity) {\n    return new IteratorWithOperators(new slice_1.SliceIterator(this.source, start, end));\n  }\n  /**\n   * Returns a new Iterator that flattens items emitted by the Iterator a single level deep\n   */\n\n\n  flatten() {\n    return new IteratorWithOperators(new flatten_1.FlattenIterator(this.source));\n  }\n\n  reduce(iteratee, accumulator) {\n    let result;\n\n    if (accumulator === undefined) {\n      result = this.source.next();\n\n      if (result.done) {\n        throw new TypeError('Reduce of empty Iterator with no initial value');\n      }\n\n      accumulator = result.value;\n    }\n\n    while (true) {\n      result = this.source.next();\n\n      if (result.done) {\n        break;\n      }\n\n      accumulator = iteratee(accumulator, result.value);\n    }\n\n    return accumulator;\n  }\n\n  find(predicate) {\n    let result;\n\n    while (true) {\n      result = this.source.next();\n\n      if (result.done) {\n        return undefined;\n      }\n\n      if (predicate(result.value)) {\n        return result.value;\n      }\n    }\n  }\n  /**\n   * Iterates and checks if `value` is emitted by the Iterator\n   *\n   * @param value The value to search\n   */\n\n\n  includes(value) {\n    let result;\n\n    do {\n      result = this.source.next();\n\n      if (!result.done && result.value === value) {\n        return true;\n      }\n    } while (!result.done);\n\n    return false;\n  }\n  /**\n   * Iterates and checks if `predicate` returns truthy for any element emitted by the Iterator\n   */\n\n\n  some(predicate) {\n    let result;\n\n    do {\n      result = this.source.next();\n\n      if (!result.done && predicate(result.value)) {\n        return true;\n      }\n    } while (!result.done);\n\n    return false;\n  }\n  /**\n   * Iterates and checks if `predicate` returns truthy for all elements emitted by the Iterator\n   */\n\n\n  every(predicate) {\n    let result;\n\n    do {\n      result = this.source.next();\n\n      if (!result.done && !predicate(result.value)) {\n        return false;\n      }\n    } while (!result.done);\n\n    return true;\n  }\n  /**\n   * Iterates and invokes `iteratee` for every element emitted by the Iterator\n   */\n\n\n  forEach(iteratee) {\n    let result;\n\n    while (true) {\n      result = this.source.next();\n\n      if (result.done) {\n        break;\n      }\n\n      iteratee(result.value);\n    }\n  }\n  /**\n   * Iterates and joins all elements emitted by the Iterator together as a string separated by an optional separator\n   */\n\n\n  join(separator = ',') {\n    let joined = '';\n    let result;\n\n    while (true) {\n      result = this.source.next();\n\n      if (result.done) {\n        break;\n      }\n\n      joined += separator + result.value;\n    }\n\n    return joined.substr(separator.length);\n  }\n  /**\n   * Iterates and returns all items emitted by the Iterator as an array.\n   * Equivalent to passing the Iterator to `Array.from()`\n   */\n\n\n  toArray() {\n    return Array.from(this);\n  }\n  /**\n   * Iterates and returns all items emitted by the Iterator as an ES6 Set.\n   * Equivalent to passing the Iterator to `new Set()`\n   */\n\n\n  toSet() {\n    const set = new Set();\n\n    while (true) {\n      const {\n        value,\n        done\n      } = this.next();\n\n      if (done) {\n        return set;\n      }\n\n      set.add(value);\n    }\n  }\n  /**\n   * Iterates and returns all `[key, value]` paris emitted by the Iterator as an ES6 Map.\n   * Equivalent to passing the Iterator to `new Map()`\n   */\n\n\n  toMap() {\n    return new Map(this);\n  }\n\n}\n\nexports.IteratorWithOperators = IteratorWithOperators;\n/**\n * Creates an Iterator with advanced chainable operator methods for any Iterable or Iterator\n */\n\nfunction iterate(collection) {\n  return new IteratorWithOperators(utils_1.toIterator(collection));\n}\n\nexports.iterate = iterate;\n/**\n * Creates an Iterator that emits pairs of values from the two passed Iterators\n */\n\nfunction zip(a, b) {\n  return new IteratorWithOperators(new zip_1.ZipIterator(utils_1.toIterator(a), utils_1.toIterator(b)));\n}\n\nexports.zip = zip;\nexports.default = iterate; //# sourceMappingURL=iterate.js.map","map":null,"metadata":{},"sourceType":"script"}